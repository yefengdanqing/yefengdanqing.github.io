<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>样例模板</title>
    <url>/2022/03/04/markdown%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>#一阶标题 （快捷键Ctrl+1）</p>
<p>##二阶标题 （快捷键Ctrl+2）</p>
<p>###三阶标题 （快捷键Ctrl+3）</p>
<p>####四阶标题 （快捷键Ctrl+4）</p>
<p>#####五阶标题 （快捷键Ctrl+5）</p>
<p>######六阶标题 （快捷键Ctrl+6）</p>
<span id="more"></span>

<h2 id="如何生成目录"><a href="#如何生成目录" class="headerlink" title="如何生成目录"></a>如何生成目录</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">@[TOC]目录</span><br><span class="line"></span><br><span class="line">在文章开始地方输入[toc]，即可在对应位置插入目录</span><br><span class="line">@[TOC]目录</span><br><span class="line"></span><br><span class="line">以下不用写，直接写@[TOC](目录)即可自动获到目录中</span><br><span class="line">#一阶标题 （快捷键Ctrl+1）</span><br><span class="line">##二阶标题 （快捷键Ctrl+2）</span><br><span class="line">###三阶标题 （快捷键Ctrl+3）</span><br><span class="line">####四阶标题 （快捷键Ctrl+4）</span><br><span class="line">#####五阶标题 （快捷键Ctrl+5）</span><br><span class="line">######六阶标题 （快捷键Ctrl+6）</span><br><span class="line">注：凡是文章标题带有#（1-n个）的都会被捕获到目录中。</span><br></pre></td></tr></table></figure>

<h2 id="文本居中"><a href="#文本居中" class="headerlink" title="文本居中"></a>文本居中</h2><p>这是要居中的文本内容\</p>
<p><strong>注</strong>：Typora目前并不会直接预览居中效果——相应的效果只有输出文本的时候才会显现。</p>
<p>语法：<center>文本</center>,<p align="left">文本</p>,<p lign="right">文本</p></p>
<h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>下划线使用格式 下划线的内容&lt;\u&gt; 或者快捷键Ctrl+U</p>
<p>下划线在Typora显示形式是 这就是我亲测的下划线</p>
<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>删除线使用格式：~~ 删除线的内容</p>
<h2 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h2><p>前面某个字段使用两个<em>，*加粗字体</em> 或者快捷键Ctrl+B</p>
<h2 id="字体倾斜"><a href="#字体倾斜" class="headerlink" title="字体倾斜"></a>字体倾斜</h2><p>使用一个”星“，<em>字体倾斜了</em> 或者快捷键Ctrl+I</p>
<h2 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h2><p>直接拖你想要图片进来即可</p>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><ul>
<li>使用快捷键Ctrl+K</li>
<li>使用2个反斜杠””，<br>[百度][<a href="https://link.zhihu.com/?target=https://www.baidu.com/">https://www.baidu.com/</a>]</li>
</ul>
<p><a href="https://link.zhihu.com/?target=https://www.baidu.com/">百度一下</a></p>
<p><strong>注</strong>：按住Ctrl键+点击上面链接就可以直接访问该链接</p>
<h2 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h2><p>三个反引号个（&#96;&#96;&#96;）+编程语言即可</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//设置线程名字</span><br><span class="line">thread.setName(&quot;线程1&quot;); </span><br><span class="line">thread1.setName(&quot;线程2&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="表格的使用"><a href="#表格的使用" class="headerlink" title="表格的使用"></a>表格的使用</h2><p>第一种：快捷键<strong>Ctrl+T</strong></p>
<p>第二种：|ID|name|age|回车即可</p>
<p>学号姓名年龄20200506MarkerHunJava35</p>
<h2 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h2><p>- [ ] 文字 （<strong>注</strong>：注意用空格隔开）</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Java</li>
<li><input checked="" disabled="" type="checkbox"> 大数据</li>
<li><input disabled="" type="checkbox"> 人工智能</li>
<li><input disabled="" type="checkbox"> 机器学习</li>
</ul>
<h2 id="有序无序列表"><a href="#有序无序列表" class="headerlink" title="有序无序列表"></a>有序无序列表</h2><p><strong>创建无序列</strong> :+ 、- 、* （后面加空格）</p>
<p><strong>多行无序列表</strong>:</p>
<ul>
<li><p>Java</p>
</li>
<li><ul>
<li><p>容器</p>
</li>
<li><ul>
<li>HashMap</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>有序列表</strong>:(1.)空格</p>
<ol>
<li>Java</li>
<li>Biodata</li>
</ol>
<p><strong>多行有序列表：</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">1. Java</span><br><span class="line">2. Biodata</span><br><span class="line">    1. Java</span><br><span class="line">    2. Biodata</span><br></pre></td></tr></table></figure>

<h2 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">***或者- - -</span><br></pre></td></tr></table></figure>

<h2 id="引用的使用格式"><a href="#引用的使用格式" class="headerlink" title="引用的使用格式"></a>引用的使用格式</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&gt;+空格</span><br></pre></td></tr></table></figure>

<h2 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">:单词</span><br></pre></td></tr></table></figure>

<h2 id="数学表达式"><a href="#数学表达式" class="headerlink" title="数学表达式"></a>数学表达式</h2><p>Typora支持加入用LaTeX写成的数学公式，并且在软件界面下用MathJax直接渲染，数学公式分为两种参考**<a href="https://link.zhihu.com/?target=https://mathpix.com/">Mathpix Snip</a>**</p>
<ul>
<li>行内公式 <code>$ ... $</code></li>
<li>行间公式 <code>$$ ... $$</code>,（或者$$+回车）<br><strong>注</strong>：行间公式形式是将数学式插在文本行之间（多行公式、公式组和微积分方程等复杂的数学式都是采用行间） <strong>注</strong>：行内公式形式是将数学式插入文本行之内（适合编写简 短的数学式） <strong>如</strong>：将公式插入到本行内，符号：<code>$公式内容$</code>，$xyz$或“$$”+回车即可</li>
</ul>
<p>#### 1、上标、下标、求和、括号、分式、根号</p>
<p><strong>语法</strong>：行内公式输入在两个<code>$$</code>之间，行外公公式<code>$$内容公式$$</code>或<code>$$</code>+回车即可输入。</p>
<p><img src="https://pic3.zhimg.com/80/v2-fc1eb7e3e05ef1b0bbb7a47975db5de2_1440w.jpg" alt="img"></p>
<h3 id="2、基本运算符"><a href="#2、基本运算符" class="headerlink" title="2、基本运算符"></a>2、基本运算符</h3><p><img src="https://pic3.zhimg.com/80/v2-c3703593a2e990069e3834247b437206_1440w.jpg" alt="img"></p>
<h3 id="3、三角函数、指数、对数"><a href="#3、三角函数、指数、对数" class="headerlink" title="3、三角函数、指数、对数"></a>3、三角函数、指数、对数</h3><p><img src="https://pic2.zhimg.com/80/v2-f525471ca6da7be4fe0cfb25717b7411_1440w.jpg" alt="img"></p>
<h3 id="4、高等数学相关运算符"><a href="#4、高等数学相关运算符" class="headerlink" title="4、高等数学相关运算符"></a>4、高等数学相关运算符</h3><p><img src="https://pic4.zhimg.com/80/v2-a3e3be0b70dc25c0d09a22544136174f_1440w.jpg" alt="img"></p>
<h3 id="6、希腊字母"><a href="#6、希腊字母" class="headerlink" title="6、希腊字母"></a>6、希腊字母</h3><p><img src="https://pic4.zhimg.com/80/v2-f8cf4f5d21042f66e5ecc0c4f1c415cb_1440w.jpg" alt="img"></p>
<h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">	gantt</span><br><span class="line">	        dateFormat  YYYY-MM-DD</span><br><span class="line">	        title Adding GANTT diagram functionality to mermaid</span><br><span class="line">	        section 现有任务</span><br><span class="line">	        已完成               :done,    des1, 2019-09-02,220-01-20</span><br><span class="line">	        进行中               :active,  des2, 2020-05-06, 3d</span><br><span class="line">	        计划一               :         des3, after des2, 5d</span><br><span class="line">	        计划二               :         des4, after des3, 5d</span><br><span class="line">　```</span><br></pre></td></tr></table></figure>

<p><img src="https://pic4.zhimg.com/80/v2-01b334770f043d6ae251f12e7fc5947b_1440w.jpg" alt="img"></p>
<h3 id="Mermaid流程图"><a href="#Mermaid流程图" class="headerlink" title="Mermaid流程图"></a>Mermaid流程图</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">	graph LR</span><br><span class="line">	graph LR</span><br><span class="line">	A[老鹰] -- 吃 --&gt; B((小鸡))</span><br><span class="line">	A -- 吃 --&gt; C(蛇)</span><br><span class="line">	B -- 吃--&gt; D&#123;虫&#125;</span><br><span class="line">	C --&gt; D</span><br><span class="line">	```</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-10220c614d3474fbea35b656187271e9_1440w.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=https://mermaid-js.github.io/mermaid/%23/">更多参考文档</a></p>
<h3 id="Flowchart流程图"><a href="#Flowchart流程图" class="headerlink" title="Flowchart流程图"></a>Flowchart流程图</h3><p><img src="https://pic2.zhimg.com/80/v2-7accbf1332cdf0247a6036928a470eed_1440w.jpg" alt="img"></p>
<p><a href="https://link.zhihu.com/?target=http://flowchart.js.org/">更多参考</a></p>
]]></content>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2023/05/04/%E6%A0%B7%E4%BE%8B%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><p>* </p>
<h5 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h5><p>假如王二狗和牛翠花约好在天安门约会，两人从起点到目的地可以借助的通行方式比较多，至于选那种方式完全因人而异。</p>
<h5 id="使用方法（核心代码）"><a href="#使用方法（核心代码）" class="headerlink" title="使用方法（核心代码）"></a>使用方法（核心代码）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>；</span><br></pre></td></tr></table></figure>



<h4 id="模板方法模式适合应用场景"><a href="#模板方法模式适合应用场景" class="headerlink" title="模板方法模式适合应用场景"></a>模板方法模式适合应用场景</h4><h4 id="实现方式（类图）"><a href="#实现方式（类图）" class="headerlink" title="实现方式（类图）"></a>实现方式（类图）</h4><h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><p>优点：</p>
<p>缺点：</p>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4><span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>资料</title>
    <url>/2022/03/04/%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<ol>
<li><p>设计模式</p>
<ol>
<li><a href="https://github.com/ZachL1/Bilibili-plus">https://github.com/ZachL1/Bilibili-plus</a></li>
</ol>
</li>
<li><p>指南类资源<br><strong>C++ Core Guidelines</strong><br>地址：<a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html">https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html</a><br><strong>Super FAQ C++</strong><br>地址：<a href="https://isocpp.org/wiki/faq">https://isocpp.org/wiki/faq</a></p>
</li>
<li><p>c++</p>
<p><a href="https://zhuanlan.zhihu.com/p/440130614">https://zhuanlan.zhihu.com/p/440130614</a></p>
</li>
<li><p>aa</p>
</li>
<li></li>
</ol>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>工作中遗留点</title>
    <url>/2022/03/04/%E5%B7%A5%E4%BD%9C%E9%81%97%E7%95%99/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%97%E7%95%99%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>工作中有些知识点可能需要深入学习</p>
<span id="more"></span>

<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p><a href="https://mp.weixin.qq.com/s/dbhGFfYYiDgPjcVx75FasA">https://mp.weixin.qq.com/s/dbhGFfYYiDgPjcVx75FasA</a></p>
<hr>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><hr>
<p>编译器插桩模块</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><hr>
<h1 id="python"><a href="#python" class="headerlink" title="python"></a>python</h1><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p>tensorflow，Caffe，MXnet，PyTorch了解</p>
]]></content>
  </entry>
  <entry>
    <title>样例模板</title>
    <url>/2022/03/04/%E5%B7%A5%E4%BD%9C%E9%81%97%E7%95%99/%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>

<p><a href="https://xianbai.me/learn-md/article/syntax/horizontal-rule.html">makedown语法</a></p>
<p><a href="https://xianbai.me/learn-md/article/syntax/horizontal-rule.html">https://xianbai.me/learn-md/article/syntax/horizontal-rule.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/04/21/%E5%B7%A5%E4%BD%9C%E9%81%97%E7%95%99/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 推荐系统</span><br><span class="line">toc: true</span><br><span class="line">date: 2022-06-04 22:26:59</span><br><span class="line">tags:</span><br><span class="line">- 推荐</span><br><span class="line">categories:</span><br><span class="line">- 搜广推</span><br><span class="line">typora-root-url: ..\img</span><br></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-5bc825cf962e4c135f348db4b985b09d_720w.jpg" alt="img"></p>
<span id="more"></span>

<h6 id="调权"><a href="#调权" class="headerlink" title="调权"></a>调权</h6><p>刷新行为的调权</p>
<p>作者等级调权</p>
<p>冷启用户</p>
<p>弹幕</p>
<p>关注关系</p>
<p>低&#x2F;高内容质量</p>
<p>类目</p>
<p>deeplink</p>
<p>设备</p>
<p>用商资源</p>
<h6 id="多样性"><a href="#多样性" class="headerlink" title="多样性"></a>多样性</h6><p>软打散</p>
<ul>
<li>候选视频”在”cate”的”距离（index）</li>
<li>“候选视频”在tag的”距离“</li>
<li>“候选视频”与“候选集”相同的视频</li>
<li>“候选视频”与“候选集”cate相同的视频</li>
<li>“候选视频”与“候选集”tag相同的视频</li>
</ul>
<p>硬打散</p>
<ul>
<li>判断是否满足最小相隔距离限制: “本视频”和”相似视频”的距离 &gt;&#x3D; max_nearest_cnt, 则返回true</li>
<li>判断是否满足最大”连续视频个数”限制: “连续视频个数” &lt;&#x3D; max_nearest_cnt, 则返回true</li>
<li>.最近max_nearest_cnt条视频中，”相似视频”最大总数限制，最外面的vector: index&#x3D;0、1、2、3对应的是CATE, SUB_CATE, TAG, SEMANTIC，最内层的vector: 前面index条视频中，相同视频的数量</li>
</ul>
<h6 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h6><ul>
<li>原创冷启队列过滤暧昧视频，新作者冷启队列过滤暧昧资源</li>
<li>互联网人群过滤冷启通道</li>
<li>类目过滤，获取需要过滤的二级类目词典</li>
<li>作者等级过滤，作者质量分限流,分段限流，用户关注作者内容豁免</li>
<li>对于低活且非新用户豁免335路召回的资源，小流量实验</li>
<li>地理位置的过滤</li>
<li>搜索相关的过滤</li>
<li>相关推荐和连播的过滤</li>
</ul>
<h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>arena对于分配和释放都是针对内存一次性的，减少了申请和释放对象</p>
]]></content>
  </entry>
  <entry>
    <title>二分查找总结</title>
    <url>/2022/02/22/lc/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<p>二分查找</p>
<p><a href="https://www.zhihu.com/question/36132386/answer/530313852?utm_source=qq&amp;utm_medium=social&amp;utm_oi=37067136434176">https://www.zhihu.com/question/36132386/answer/530313852?utm_source=qq&amp;utm_medium=social&amp;utm_oi=37067136434176</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;skt.h&quot;</span></span></span><br><span class="line">   <span class="comment">//lower_bound，大于等于某个数</span></span><br><span class="line">   <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>(), mid = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">       mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">           l = mid + <span class="number">1</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> l;</span><br><span class="line">    <span class="comment">//upper_bound, 大于给定元素值所在的位置,之前的位置刚好相等</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = nums.<span class="built_in">size</span>();</span><br><span class="line">    mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt; y) &#123;</span><br><span class="line">        mid = x + (y-x)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">             x = mid + <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             y = mid;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">	<span class="comment">//x-1 是小于等于目标数的位置</span></span><br><span class="line">    <span class="comment">//唯一区别就是一个是小于，一个是小于等于;区间都是左闭右开；右边界不用减1</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>变形</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binary_eg(std::vector&lt;int&gt;&amp; vect, int target) &#123;</span><br><span class="line">    int l = 0, r = vect.size() - 1;</span><br><span class="line">    int mid = 0;</span><br><span class="line">    while(l &lt;= r) &#123;</span><br><span class="line">        mid = (l+r) / 2;</span><br><span class="line">        if (target &lt;= vect[mid]) &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">//大于</span><br><span class="line">int binary_gt(std::vector&lt;int&gt;&amp; vect, int target) &#123;</span><br><span class="line">    int l = 0, r = vect.size() - 1;</span><br><span class="line">    int mid = 0;</span><br><span class="line">    while(l &lt;= r) &#123;</span><br><span class="line">        mid = (l+r) / 2;</span><br><span class="line">        if (target &lt; vect[mid]) &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line">//小于等于---大于减1或者返回right</span><br><span class="line">int binary_lt(std::vector&lt;int&gt;&amp; vect, int target) &#123;</span><br><span class="line">    return binary_gt(vect, target) - 1;</span><br><span class="line">&#125;</span><br><span class="line">int binary_lt1(std::vector&lt;int&gt;&amp; vect, int target) &#123;</span><br><span class="line">    int l = 0, r = vect.size() - 1;</span><br><span class="line">    int mid = 0;</span><br><span class="line">    while(l &lt;= r) &#123;</span><br><span class="line">        mid = (l+r) / 2;</span><br><span class="line">        if (target &lt; vect[mid]) &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">//小于</span><br><span class="line">int binary_ls(std::vector&lt;int&gt;&amp; vect, int target) &#123;</span><br><span class="line">    return binary_eg(vect, target) - 1;</span><br><span class="line">&#125;</span><br><span class="line">int binary_ls1(std::vector&lt;int&gt;&amp; vect, int target) &#123;</span><br><span class="line">    int l = 0, r = vect.size() - 1;</span><br><span class="line">    int mid = 0;</span><br><span class="line">    while(l &lt;= r) &#123;</span><br><span class="line">        mid = (l+r) / 2;</span><br><span class="line">        if (target &lt;= vect[mid]) &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::vector&lt;int&gt; nums = &#123;2,3,4,5,5,5,5,6,7,9,9,9,10,11&#125;;</span><br><span class="line">    std::cout &lt;&lt; &quot;vector size:&quot; &lt;&lt; nums.size() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;eg:&quot; &lt;&lt; binary_eg(nums,9) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;gt:&quot; &lt;&lt; binary_gt(nums,9) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;lt:&quot; &lt;&lt; binary_lt(nums,9) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;lt1:&quot; &lt;&lt; binary_lt1(nums,9) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;ls:&quot; &lt;&lt; binary_ls(nums,9) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;ls1:&quot; &lt;&lt; binary_ls1(nums,9) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>排序总结</title>
    <url>/2022/03/04/lc/%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><p>注意点：在递归的时候要判断是否越界</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index = <span class="built_in">rand</span>() % (r-l+<span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">swap</span>(nums[l], nums[index]);</span><br><span class="line">        <span class="type">int</span> x = nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; x &lt;= nums[r]) r--;</span><br><span class="line">            <span class="built_in">swap</span>(nums[l], nums[r]);</span><br><span class="line">            <span class="comment">//nums[l] = nums[r];</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; x &gt;= nums[l]) l++;</span><br><span class="line">            <span class="built_in">swap</span>(nums[r], nums[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = x;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">partition</span>(l, r, nums);</span><br><span class="line">        <span class="built_in">quick_sort</span>(l, mid - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="built_in">quick_sort</span>(mid + <span class="number">1</span>, r, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">quick_sort</span>(<span class="number">0</span>, len - <span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h6 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里是merge两个有序数组，然后将临时排好序的数据拷贝过去 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(r-l+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">                tmp[k++] = nums[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            tmp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里是小于k或者小于r-l+1,不能等于；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; k; m++) &#123;</span><br><span class="line">            nums[l+m] = tmp[m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归的逐层向下拆分数组，直到一个数组只有一个元素，当有0个元素的时候，</span></span><br><span class="line"><span class="comment">//直接返回</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">merge_sort</span>(nums, l, mid);</span><br><span class="line">        <span class="built_in">merge_sort</span>(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">merge</span>(nums, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//quick_sort(0, len - 1, nums);</span></span><br><span class="line">        <span class="built_in">merge_sort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h6 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h6><p>由于堆排序是完全二叉树，直接通过数组就可以保存树形结构；数组的下标可以作为树节点的索引，比如：当从0 开始的时候，左孩子是2<em>i+1；右孩子是2</em>i + 2;如果给定一个下标i，其父亲节点的的索引是（i-1）&#x2F;2;</p>
<p>把长度作为限制条件进行递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapfiy</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> len, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= len)   <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> max = index;</span><br><span class="line">    <span class="type">int</span> c1 = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> c2 = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (c1 &lt; len &amp;&amp; nums[c1] &gt; nums[max]) &#123;</span><br><span class="line">        max = c1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c2 &lt; len &amp;&amp; nums[c2] &gt; nums[max]) &#123;</span><br><span class="line">        max = c2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index != max) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[index], nums[max]);</span><br><span class="line">        <span class="built_in">heapfiy</span>(nums, len, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在建堆的时候从最后一个节点的父节点开始调整，从底到顶，一次调整好；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_heap</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> last_index = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> parent = (last_index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = parent; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapfiy</span>(nums, nums.<span class="built_in">size</span>(), i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">build_heap</span>(nums);</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//交换了之后从跟节点开始调整，一直到交换前，此时的i是索引，也代表当前调整的节点的数量</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">heapfiy</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：在leetcod上进行提交的时候，发现归并用了空间和时间最多，由于中间有临时数组的拷贝，所以导致性能很差，在工作中要注意</p>
<p><img src="C:\Users\sunketo\AppData\Roaming\Typora\typora-user-images\image-20220416120114157.png" alt="image-20220416120114157"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Valgrind使用</title>
    <url>/2022/03/04/%E6%80%A7%E8%83%BD%E6%80%BB%E7%BB%93/Valgrind%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>下载：<a href="https://valgrind.org/downloads/current.html%E7%9B%AE%E5%89%8D%E6%98%AF%E4%B8%8B%E8%BD%BD%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC">https://valgrind.org/downloads/current.html目前是下载最新版本</a></p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -jxvf xxxx</span><br><span class="line">cd valgrind-3.19.0</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>



<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>内存泄漏定位</title>
    <url>/2022/06/14/%E6%80%A7%E8%83%BD%E6%80%BB%E7%BB%93/%E5%86%85%E5%AD%98%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h3 id="asan和lsan简介"><a href="#asan和lsan简介" class="headerlink" title="asan和lsan简介"></a>asan和lsan简介</h3><hr>
<h3 id="asan使用"><a href="#asan使用" class="headerlink" title="asan使用"></a>asan使用</h3><span id="more"></span>

<hr>
<h4 id="AddressSanitizerFlags"><a href="#AddressSanitizerFlags" class="headerlink" title="AddressSanitizerFlags"></a>AddressSanitizerFlags</h4><h5 id="compiler-flags"><a href="#compiler-flags" class="headerlink" title="compiler flags"></a>compiler flags</h5><table>
<thead>
<tr>
<th>flag</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>-fsanitize&#x3D;address</td>
<td>Enable <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a></td>
</tr>
<tr>
<td>-fno-omit-frame-pointer</td>
<td>Leave frame pointers. Allows the fast unwinder to function properly.</td>
</tr>
<tr>
<td>-fsanitize-blacklist&#x3D;path</td>
<td>Pass a <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer#turning-off-instrumentation">blacklist file</a></td>
</tr>
<tr>
<td>-fno-common</td>
<td>Do not treat global variable in C as common variables (allows ASan to instrument them</td>
</tr>
<tr>
<td>-fsanitize-recover&#x3D;address</td>
<td>一般后台程序为保证稳定性，不能遇到错误就简单退出，而是继续运行，采用该选项支持内存出错之后程序继续运行，需要叠加设置<em>ASAN_OPTIONS&#x3D;halt_on_error&#x3D;0</em>才会生效；若未设置此选项，则内存出错即报错退出</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">SET( CMAKE_CXX_FLAGS_ASAN <span class="string">&quot;-O1 -g -fsanitize=address -fsanitize-recover=address -fno-omit-frame-pointer&quot;</span> CACHE STRING</span><br><span class="line">    <span class="string">&quot;Flags used by the C++ compiler during asan builds.&quot;</span></span><br><span class="line">    FORCE )</span><br><span class="line">SET( CMAKE_C_FLAGS_ASAN <span class="string">&quot;-O1 -g -fsanitize=address -fsanitize-recover=address -fno-omit-frame-pointer&quot;</span> CACHE STRING</span><br><span class="line">    <span class="string">&quot;Flags used by the C compiler during asan builds.&quot;</span></span><br><span class="line">    FORCE )</span><br><span class="line">SET( CMAKE_EXE_LINKER_FLAGS_ASAN</span><br><span class="line">    <span class="string">&quot;-static-libasan&quot;</span> CACHE STRING</span><br><span class="line">    <span class="string">&quot;Flags used for linking binaries during asan builds.&quot;</span></span><br><span class="line">    FORCE )</span><br><span class="line">SET( CMAKE_SHARED_LINKER_FLAGS_ASAN</span><br><span class="line">    <span class="string">&quot;-static-libasan&quot;</span> CACHE STRING</span><br><span class="line">    <span class="string">&quot;Flags used for linking shared libraries during asan builds.&quot;</span></span><br><span class="line">    FORCE )</span><br><span class="line">SET(CMAKE_CXX_FLAGS <span class="string">&quot;-w -g -pthread -fno-omit-frame-pointer -fsanitize=address -fsanitize-recover=address -fno-stack-protector&quot;</span>)</span><br><span class="line">SET(CMAKE_CXX_FLAGS_DEBUG $&#123;CMAKE_CXX_FLAGS&#125;)</span><br><span class="line">SET(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-w -g -pthread -O2 -fno-omit-frame-pointer -fsanitize=address -fsanitize-recover=address -fno-stack-protector&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="run-time-flags"><a href="#run-time-flags" class="headerlink" title="run time flags"></a>run time flags</h5><p>Most run-time flags are passed to <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer">AddressSanitizer</a> via <code>ASAN_OPTIONS</code> environment variable like this:[加了没起来]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASAN_OPTIONS=verbosity=1:malloc_context_size=20 ./a.out</span><br><span class="line"># halt_on_error=0：检测内存错误后继续运行</span><br><span class="line"></span><br><span class="line"># detect_leaks=1:使能内存泄露检测</span><br><span class="line"></span><br><span class="line"># malloc_context_size=15：内存错误发生时，显示的调用栈层数为15</span><br><span class="line"></span><br><span class="line"># log_path=/home/xos/asan.log:内存检查问题日志存放文件路径</span><br><span class="line"></span><br><span class="line"># suppressions=$SUPP_FILE:屏蔽打印某些内存错误</span><br><span class="line"></span><br><span class="line">export ASAN_OPTIONS=halt_on_error=0:use_sigaltstack=0:detect_leaks=1:malloc_context_size=20:log_path=//data/recommend/ranker_service/asan.log</span><br><span class="line"></span><br><span class="line"># unmap_shadow_on_exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">export ASAN_SYMBOLIZER_PATH=/usr/bin/llvm-symbolizer</span><br><span class="line">export ASAN_OPTIONS=symbolize=true:halt_on_error=false:abort_on_error=false:disable_coredump=false:unmap_shadow_on_exit=true:disable_core=false:sleep_before_dying=15:log_path=ranker_service_skt</span><br><span class="line">#LD_PRELOAD=/usr/lib64/libasan.so.4导入这个变量会有一些问题？</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>工作中的性能总结</title>
    <url>/2022/03/04/%E6%80%A7%E8%83%BD%E6%80%BB%E7%BB%93/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%84%E6%80%A7%E8%83%BD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h5 id="广告创意读取"><a href="#广告创意读取" class="headerlink" title="广告创意读取"></a>广告创意读取</h5><p>由于要迁移mongodb库，由于启动程序的时候全量从mongodb拉素材比较慢，因此通过本地加载的方式拉全量，程序做增量变更</p>
<p>旧mongodb库是500万数据，新的mongodb是340万数据；</p>
<p><strong>旧方案：本地插件程序dump mongodb的数据为flatbuffer二进制数据，saasrs直接序列化到内存的flatbuffer 结构中</strong></p>
<p><strong>新方案1：mongodb export【官方出品】插件 导出为json数据文件，然后saas rs 读取json并解析到PadCreative结构中</strong></p>
<p>新方案2：mongodb export插件 导出为json文件后进行gz压缩，saas rs 读取后进行解压，然后解析到PadCreative结构中</p>
<p>新方案3：mongodb export插件 导出为json文件后，按行读取后放入队列，多线程解析并加锁写入内存数据结构</p>
<p><strong>结论</strong>：按照耗和整个处理过程来说，目前用方案3；因为导出的过程可以放到平台，同时也可以去掉增量更新锁。</p>
<table>
<thead>
<tr>
<th>总条数</th>
<th>实际加载条数</th>
<th>文件大小</th>
<th>全量数据解析为结构体的耗时</th>
</tr>
</thead>
<tbody><tr>
<td>3377324</td>
<td>3364382</td>
<td>creative.json（2.4G）</td>
<td>55秒</td>
</tr>
<tr>
<td>3377324</td>
<td>3364382</td>
<td>creative.json.gz(250m)</td>
<td>60秒</td>
</tr>
<tr>
<td>3377324</td>
<td>3377324</td>
<td>creative.json（2.4G）</td>
<td>16秒</td>
</tr>
</tbody></table>
<span id="more"></span>

]]></content>
  </entry>
  <entry>
    <title>性能优化</title>
    <url>/2022/03/04/%E6%80%A7%E8%83%BD%E6%80%BB%E7%BB%93/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><hr>
<h4 id="cpu火焰图"><a href="#cpu火焰图" class="headerlink" title="cpu火焰图"></a>cpu火焰图</h4><p>目前看到cpu-clock和cycles的结果是一样的</p>
<h5 id="安装-perf"><a href="#安装-perf" class="headerlink" title="安装 perf"></a>安装 perf</h5><p>yum install -y perf</p>
<h5 id="生成-perf-data"><a href="#生成-perf-data" class="headerlink" title="生成 perf.data"></a>生成 perf.data</h5><p>pid&#x3D;$(pgrep service)</p>
<p>perf record -e cpu-clock -F 99 -p $pid -g – sleep 30</p>
<h5 id="展示-perf-data"><a href="#展示-perf-data" class="headerlink" title="展示 perf.data"></a>展示 perf.data</h5><p>perf report –show-total-period</p>
<h5 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h5><p>git clone <a href="https://github.com/brendangregg/FlameGraph">https://github.com/brendangregg/FlameGraph</a></p>
<p>perf script | FlameGraph&#x2F;stackcollapse-perf.pl | FlameGraph&#x2F;flamegraph.pl &gt; flamegraph.svg</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/flamegraph_skt_2.svg" alt="flamegraph_skt_2"></p>
<h4 id="Heap火焰图"><a href="#Heap火焰图" class="headerlink" title="Heap火焰图"></a>Heap火焰图</h4><p>Tcmalloc</p>
<p>jemalloc不能看火焰图</p>
<p>perf跟踪malloc&#x2F;free；跟踪brk；跟踪mmap；跟踪页错误通过gperftools来查看内存profiler结构</p>
<p>pprof支持三种，第一种是cpu采样，第二种是堆内存，第三种是内存泄漏</p>
<p>cpu采样用profiler.h文件，内存是heap_profile.h,有2种方式导出profile文件</p>
<p> 静态dump方法：</p>
<p>​    直接定义一个环境变量HEAPPROFILE来指定dumpprofile文件的位置，如：&#x2F;tmp&#x2F;test.log,它将会在&#x2F;tmp&#x2F;目录下生成很多类似&#x2F;tmp&#x2F;test.log.0003.heap文件名的文件</p>
<p>​    env HEAPPROFILE&#x3D;”&#x2F;tmp&#x2F;test.log” &#x2F;test&#x2F;testprog</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">env</span> HEAPPROFILE=/tmp/ranker_service/ranker_service HEAPCHECK=normal HEAP_PROFILE_ALLOCATION_INTERVAL=1073741824 HEAP_PROFILE_INUSE_INTERVAL=104857600 ./bin/ranker_service <span class="variable">$exec_param</span></span></span><br></pre></td></tr></table></figure>



<p>HeapProfilerStart() 用来开始内存分析</p>
<p>HeapProfilerStop(). 用来终止内存分析</p>
<p>这样就只会在开始和结束之间产生dump profiler文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GPROF</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;gperftools/profiler.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gperftools/heap-profiler.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_GPROFTOOLS</span></span><br><span class="line">    <span class="keyword">if</span> (signum == SIGUSR1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isStarted)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">HeapProfilerStart</span>(<span class="string">&quot;gprof/rs.log&quot;</span>);</span><br><span class="line">            <span class="comment">//ProfilerStart(&quot;test.prof&quot;);</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ProfilerStart success\n&quot;</span>);</span><br><span class="line">            isStarted++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">HeapProfilerDump</span>();</span><br><span class="line">            <span class="comment">//ProfilerFlush();</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ProfilerFlush success\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (signum == SIGUSR2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//ProfilerStop();</span></span><br><span class="line">        <span class="built_in">HeapProfilerStop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ProfilerStop success\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_GPROFTOOLS</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGUSR1, gprofStartAndStop);</span><br><span class="line">    <span class="built_in">signal</span>(SIGUSR2, gprofStartAndStop);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><ul>
<li>HEAP_PROFILE_ALLOCATION_INTERVAL</li>
</ul>
<p>程序内存每增长这一数值之后就dump 一次内存，默认是1G （1073741824）</p>
<ul>
<li>HEAP_PROFILE_INUSE_INTERVAL</li>
</ul>
<p>程序如果一次性分配内存超过这个数值dump 默认是100K</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p>pprof –text .&#x2F;bin文件 .&#x2F;heap_file.prof</p>
<p>mac安装一些绘图的软件吧</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install graphviz</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><hr>
<p>CPU迁移和上下文切换：发生上下文切换不一定会发生CPU迁移，而发生CPU迁移时肯定会发生上下文切换。发生上下文切换有可能只是把上下文从当前CPU中换出，下一次调度器还是将进程安排在这个CPU上执行。</p>
<p>系统的性能上不去？</p>
]]></content>
  </entry>
  <entry>
    <title>高并发</title>
    <url>/2022/03/04/%E6%80%A7%E8%83%BD%E6%80%BB%E7%BB%93/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<span id="more"></span>

<h5 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h5><h6 id="单机流量控制"><a href="#单机流量控制" class="headerlink" title="单机流量控制"></a>单机流量控制</h6><ul>
<li>固定计数器方法</li>
<li>滑动窗口：将时间分为特定大小的分片，然后设定特定大小的滑动窗口，每次按照这个分片大小移动；在这个窗口内有几个分片就设置几个计数器，然后加和这些计数器</li>
<li>漏铜原理：</li>
<li>令牌桶原理：程序以r的速率向桶中添加令牌，等桶中有令牌的时候，服务有请求就去拿，没有则过滤</li>
</ul>
<h6 id="集群限流"><a href="#集群限流" class="headerlink" title="集群限流"></a>集群限流</h6><ul>
<li>通过redis的incr对用户进行限流，如果超过特定的次数，就拒绝访问</li>
</ul>
<h6 id="高写入–消息队列"><a href="#高写入–消息队列" class="headerlink" title="高写入–消息队列"></a>高写入–消息队列</h6><h6 id="数据库–分库分表"><a href="#数据库–分库分表" class="headerlink" title="数据库–分库分表"></a>数据库–分库分表</h6><h6 id="缓存–"><a href="#缓存–" class="headerlink" title="缓存–"></a>缓存–</h6>]]></content>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2022/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h6 id="项目应用场景"><a href="#项目应用场景" class="headerlink" title="项目应用场景"></a>项目应用场景</h6><ul>
<li><p>场景</p>
<ul>
<li><p>日志类、配置类</p>
</li>
<li><p>数据库连接池、多线程池</p>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>线程不安全版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance* <span class="title">get_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> （obj ！= <span class="literal">nullptr</span>）&#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="built_in">SingleInstance</span>();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> SingleInstance* obj;<span class="comment">//类内静态变量初始化</span></span><br><span class="line">    <span class="built_in">SingleInstance</span>();</span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance&amp;);</span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance&amp;&amp;)</span><br><span class="line">    SingleInstance&amp; <span class="keyword">operator</span>= (<span class="type">const</span> SingleInstance&amp;);</span><br><span class="line">    SingleInstance&amp; <span class="keyword">operator</span>= (<span class="type">const</span> SingleInstance&amp;&amp;)</span><br><span class="line">    ~<span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//静态的</span></span><br><span class="line">SingleInstance SingleInstance::obj = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程安全版本(加锁版本和双检查锁版本)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::mutex mt;</span><br><span class="line">class SingleInstance &#123;</span><br><span class="line">public:</span><br><span class="line">    static SingleInstance* get_instance() &#123;</span><br><span class="line">        std::lock_guard&lt;mutex&gt; lock(mt)</span><br><span class="line">        if （obj ！= nullptr）&#123;</span><br><span class="line">            obj = new SingleInstance();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">   	static SingleInstance* obj;//类内静态变量初始化</span><br><span class="line">    SingleInstance();</span><br><span class="line">    SingleInstance(const SingleInstance&amp;);</span><br><span class="line">    SingleInstance(const SingleInstance&amp;&amp;)</span><br><span class="line">    SingleInstance&amp; operator= (const SingleInstance&amp;);</span><br><span class="line">    SingleInstance&amp; operator= (const SingleInstance&amp;&amp;)</span><br><span class="line">    ~SingleInstance();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">//静态的</span><br><span class="line">SingleInstance SingleInstance::obj = nullptr;</span><br></pre></td></tr></table></figure>
</li>
<li><p>c++11 版本</p>
<p>局部静态变量可以延迟对象的构造，等到第一次调用时才进行构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleInstance</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleInstance&amp; <span class="title">get_instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> SingleInstance obj;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleInstance</span>();</span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance&amp;);</span><br><span class="line">    <span class="built_in">SingleInstance</span>(<span class="type">const</span> SingleInstance&amp;&amp;)</span><br><span class="line">    SingleInstance&amp; <span class="keyword">operator</span>= (<span class="type">const</span> SingleInstance&amp;);</span><br><span class="line">    SingleInstance&amp; <span class="keyword">operator</span>= (<span class="type">const</span> SingleInstance&amp;&amp;)</span><br><span class="line">    ~<span class="built_in">SingleInstance</span>();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h5><p>比如每个人都要上班，每个人要打卡，也要下班；但是每个人可能做的事情不一样，有美工，有程序员，有财务等</p>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><h4 id="模板方法模式适合应用场景"><a href="#模板方法模式适合应用场景" class="headerlink" title="模板方法模式适合应用场景"></a>模板方法模式适合应用场景</h4><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>template method</title>
    <url>/2023/04/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><ul>
<li>在软件构建过程中，对于某一项任务，它常常有稳定的整体操作 结构，但各个子步骤却有很多改变的需求，或者由于固有的原因 (比如框架与应用之间的关系)而无法和任务的整体结构同时实现。</li>
<li>如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变 化或者晚期实现需求?</li>
</ul>
<span id="more"></span>

<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>模板方法模式是一种行为设计模式，它定义了一个算法骨架，允许子类重写算法的某些步骤，但不改变该算法的结构。在模板方法模式中，抽象类定义了一个模板方法，这个方法包含了一系列的具体方法，其中部分方法可由子类进行实现。</p>
<p>模板方法模式的主要优点是：</p>
<ol>
<li>将算法的结构和具体实现分离，使得算法更易于维护和扩展。</li>
<li>可以通过重写某些具体方法来改变算法的行为，同时保证算法的整体结构不受影响。</li>
<li>提高了代码的复用性，避免了相似算法的重复代码。</li>
</ol>
<!-- more -->

<p>模板方法模式通常适用于以下情况：</p>
<ul>
<li><p>多个子类有共同的方法，并且基本逻辑相同，只是具体实现不同。</p>
</li>
<li><p>不希望子类改变算法的整体结构，只允许重写某些具体方法。</p>
</li>
<li><p>希望通过一种统一的方式来执行算法，避免了算法的重复代码。</p>
</li>
<li><p>对于固定的流程，可以使用钩子的方式来处理，避开或者重新定义这些固定的流程</p>
</li>
<li><p>由稳定的部分调用不稳定的部分。</p>
</li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h5><p>比如每个人都要上班，每个人要打卡，也要下班；但是每个人可能做的事情不一样，有美工，有程序员，有财务等</p>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// libray 的run 实现具体的流程</span></span><br><span class="line"><span class="comment">// application 继承library重写重要的业务逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">library_code</span><span class="params">(Library* obj)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  obj-&gt;<span class="built_in">run</span>();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Library* base = <span class="keyword">new</span> Application;</span><br><span class="line">    <span class="built_in">library_code</span>(base);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Library* base = new Application_xxx;</span></span><br><span class="line"><span class="comment">    library_code(base);</span></span><br><span class="line"><span class="comment">    delete base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还是需要new 不同的子类对象，是否可以结合其他设计模式呢</span></span><br></pre></td></tr></table></figure>

<h4 id="模板方法模式适合应用场景"><a href="#模板方法模式适合应用场景" class="headerlink" title="模板方法模式适合应用场景"></a>模板方法模式适合应用场景</h4><ul>
<li>当你只希望客户端扩展某个特定算法步骤，而不是整个算法或其结构时，可使用模板方法模式</li>
<li>当多个类的算法除一些细微不同之外几乎完全一样时，你可使用该模式。但其后果就是只要算法发生变化，你就可能需要修改所有的类</li>
</ul>
<h4 id="实现方式（类图）"><a href="#实现方式（类图）" class="headerlink" title="实现方式（类图）"></a>实现方式（类图）</h4><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/image-20230420102358849.png" alt="image-20230420102358849"></p>
<h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><p>优点：</p>
<ul>
<li><p>你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。</p>
</li>
<li><p>你可将重复代码提取到一个超类中。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>部分客户端可能会受到算法框架的限制。</li>
<li>通过子类抑制默认步骤实现可能会导致违反<em>里氏替换原则</em>。</li>
<li>模板方法中的步骤越多， 其维护工作就可能会越困难。</li>
</ul>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4><ul>
<li>工厂方法模式是模板方法模式的一种特殊形式。 同时， <em>工厂方法</em>可以作为一个大型<em>模板方法</em>中的一个步骤。</li>
<li>模板方法基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 <em>模板方法</em>在类层次上运作， 因此它是静态的。 <em>策略</em>在对象层次上运作， 因此允许在运行时切换行为。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>策略设计模式</title>
    <url>/2022/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>策略设计模式是一种面向对象编程的模式，它允许在运行时为一个特定的算法族中的某个算法选择合适的实现。该模式通过定义一个通用接口，然后实现多个具体类来实现算法的封装和互换。这样就可以更灵活、更容易地修改或扩展一个应用程序的算法部分，而不需要修改整个应用程序的结构。</p>
<span id="more"></span>

<p>定义一系列算法，把它们一个个封装起来，并且使它们可互 相替换(变化)。该模式使得算法可独立于使用它的客户程 序(稳定)而变化(扩展，子类化)</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><ul>
<li>在软件构建过程中，某些对象使用的算法可能多种多样，经常改 变，如果将这些算法都编码到对象中，将会使对象变得异常复杂; 而且有时候支持不使用的算法也是一个性能负担。</li>
<li>如何在运行时根据需要透明地更改对象的算法?将算法与对象本 身解耦，从而避免上述问题?</li>
</ul>
<h5 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h5><p>假如王二狗和牛翠花约好在天安门约会，两人从起点到目的地可以借助的通行方式比较多，至于选那种方式完全因人而异。</p>
<h5 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Context</span><span class="params">(std::unique_ptr&lt;MapStrategy&gt;&amp;&amp; str)</span> : strategy(std::move(str)) &#123;</span></span><br><span class="line">        <span class="comment">//参数和成员变量一定不要一样命名</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">context_do_something</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        strategy-&gt;<span class="built_in">who</span>();</span><br><span class="line">        <span class="keyword">if</span> (strategy == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;strategy == nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strategy-&gt;<span class="built_in">route</span>();</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;strategy finish&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_strategy</span><span class="params">(std::unique_ptr&lt;MapStrategy&gt;&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">        strategy = std::<span class="built_in">move</span>(str);</span><br><span class="line">        <span class="comment">// strategy-&gt;who();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;MapStrategy&gt; strategy; <span class="comment">//一定要是指针或者引用，通过指针实现策略的多态， strategy的析构一定是virtual</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="模板方法模式适合应用场景"><a href="#模板方法模式适合应用场景" class="headerlink" title="模板方法模式适合应用场景"></a>模板方法模式适合应用场景</h4><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>![image-20230420003913340](&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230420003913340.png)</p>
<h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><p>优点：</p>
<ul>
<li>Strategy及其子类为组件提供了一系列可重用的算法，从而可以使 得类型在运行时方便地根据需要在各个算法之间进行切换。</li>
<li>Strategy模式提供了用条件判断语句以外的另一种选择，消除条件 判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需 要Strategy模式。</li>
<li>如果Strategy对象没有实例变量，那么各个上下文可以共享同一个 Strategy对象，从而节省对象开销。</li>
</ul>
<p>缺点：</p>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2023/04/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><ul>
<li>在软件构建过程中，我们需要为某些对象建立一种通知依赖关系，一个对象（目标对象）的状态（成员变量）发生变化的时候，其他依赖对象（观察者对象）能够得到通知；如果这种关系非常紧密或者紧耦合，将不好面对后面的变化，对之前的代码改动会很大。</li>
</ul>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>* </p>
<h5 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h5><p>假如王二狗和牛翠花约好在天安门约会，两人从起点到目的地可以借助的通行方式比较多，至于选那种方式完全因人而异。</p>
<h5 id="使用方法（核心代码）"><a href="#使用方法（核心代码）" class="headerlink" title="使用方法（核心代码）"></a>使用方法（核心代码）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>；</span><br></pre></td></tr></table></figure>



<h4 id="模板方法模式适合应用场景"><a href="#模板方法模式适合应用场景" class="headerlink" title="模板方法模式适合应用场景"></a>模板方法模式适合应用场景</h4><h4 id="实现方式（类图）"><a href="#实现方式（类图）" class="headerlink" title="实现方式（类图）"></a>实现方式（类图）</h4><h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><p>优点：</p>
<p>缺点：</p>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>一些小点</title>
    <url>/2022/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>每一种模式描述了在我们周围不断重复发生的问题，以及该问题的核心解决方案。这样我们就能重复的使用该核心解决方案，而不用做重复的工作。</p>
<span id="more"></span>

<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>向下：深入理解 封装、继承、多态的意义（ok)</p>
<p>向上：结合以上三个特性来表达真实世界，将真实世界用以上特征抽象成对象。</p>
<h4 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h4><p>方案1：即分而治之，将大问题分 解为多个小问题，将复杂问题分解为多个简单问题；</p>
<p>方案2：人们处理复制问题，只有能将这个问题进行抽象。我们要忽略所抽象出来的都是本质的特性，要忽略其非本质特性。</p>
<h4 id="面向对象（抽象）"><a href="#面向对象（抽象）" class="headerlink" title="面向对象（抽象）"></a>面向对象（抽象）</h4><h5 id="隔离变化"><a href="#隔离变化" class="headerlink" title="隔离变化"></a>隔离变化</h5><p>面向对象能将带来减小变化的影响到极低；面向对象也能适应这种变化</p>
<h5 id="各司其职"><a href="#各司其职" class="headerlink" title="各司其职"></a>各司其职</h5><p>新的对象不影响老的对象</p>
<h4 id="面向对象8大设计原则"><a href="#面向对象8大设计原则" class="headerlink" title="面向对象8大设计原则"></a>面向对象8大设计原则</h4><h5 id="依赖导致原则（dip"><a href="#依赖导致原则（dip" class="headerlink" title="依赖导致原则（dip)"></a>依赖导致原则（dip)</h5><ol>
<li><p>高层模块（稳定不变化的）不依赖于底层模块（不稳定，变化的），都依赖于抽象（稳定、不变化的）</p>
</li>
<li><p>抽象（稳定）不应该依赖实现细节（变化），实现细节应该依赖抽象</p>
</li>
</ol>
<p>将变化进行单独隔离，当做新的一部分，最好不要修改原来的部分</p>
<h5 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h5><ol>
<li><p>对扩展开放，对更改封闭</p>
</li>
<li><p>类模块应该是可扩展的，但是不支持修改</p>
<h5 id="单一原则"><a href="#单一原则" class="headerlink" title="单一原则"></a>单一原则</h5></li>
<li><p>一个类应该仅仅有一个引起他变化的原因</p>
</li>
<li><p>变化的方向隐含着累的责任</p>
<h5 id="liskov替换原则"><a href="#liskov替换原则" class="headerlink" title="liskov替换原则"></a>liskov替换原则</h5></li>
<li><p>子类必须能够替换他们的基类或者父类</p>
</li>
<li><p>继承表达类型抽象</p>
<h5 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h5></li>
<li><p>不应该强制客户程序依赖他们不用的方法</p>
</li>
<li><p>接口应该小而完备</p>
<h5 id="优先使用对象组合，而不是类继承"><a href="#优先使用对象组合，而不是类继承" class="headerlink" title="优先使用对象组合，而不是类继承"></a>优先使用对象组合，而不是类继承</h5></li>
<li><p>继承通常类似是”白箱复用“，对象组合通常类似”黑箱复用“</p>
</li>
<li><p>继承破坏了封装性，子父类耦合度比较高；组合只是要求对象有清晰的接口，不需要有</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5></li>
</ol>
<h5 id="接口封装原则"><a href="#接口封装原则" class="headerlink" title="接口封装原则"></a>接口封装原则</h5><h5 id="8"><a href="#8" class="headerlink" title="8"></a>8</h5><h4 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h4><h5 id="目的分类"><a href="#目的分类" class="headerlink" title="目的分类"></a>目的分类</h5><h6 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h6><h6 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h6><h6 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h6><p>模板方法模型</p>
<p>策略设计模式</p>
<h5 id="范围类看"><a href="#范围类看" class="headerlink" title="范围类看"></a>范围类看</h5><p>类模式处理类和类的子类之间的静态关系（继承）</p>
<p>对象模式处理对象之间的动态关系（组合）</p>
<h4 id="重构获得模式"><a href="#重构获得模式" class="headerlink" title="重构获得模式"></a>重构获得模式</h4><p>面向对象设计模式是”好的面向对象设计”，所谓好的设计模式是指那些可以“面对变化，提高复用”的设计</p>
<p>现代软件设计的特点是：需求的频繁变化。设计模式的意义是寻找变化点，在变化点处应用设计模式，从而更好的应对需求的变化；在什么地点和什么时候应用设计模式比理解设计模式本身更重要</p>
<p>设计模式使用不应该先入为主，一上来就使用设计模式是一种最愚蠢的行为，而是考虑 在<strong>重构</strong>的过程中使用设计模式。</p>
<p>重构关键技法</p>
<ul>
<li>静态–&gt;动态</li>
<li>早绑定 –&gt;晚绑定</li>
<li>继承–&gt;组合 </li>
<li>编译时依赖 –&gt;运行时依赖 </li>
<li>紧耦合 –&gt; 松耦合</li>
</ul>
<h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>fjdk</p>
<p>1. </p>
<ol start="2">
<li>高层模块（稳定不变化的）不依赖于底层模块（不稳定，变化的），都依赖于抽象（稳定、不变化的）</li>
</ol>
<!-- more -->
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>一些小点</title>
    <url>/2022/03/04/%E7%94%9F%E6%B4%BB/20230501/</url>
    <content><![CDATA[<h4 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h4><h5 id="九寨沟"><a href="#九寨沟" class="headerlink" title="九寨沟"></a>九寨沟</h5><p><strong>日则沟</strong></p>
<p>日则沟也是九寨沟景观的高潮。原始森林没有太大意思，进沟一天的朋友可选择不去。</p>
<p>推荐浏览路线：从箭竹海到熊猫海、五花海，从珍珠滩到镜海，都是非常好的徒步游览路线。栈道是绕着每个海子走的，大部分在树林中，所以距离比图上标注出来的要远不少。</p>
<p>日则沟行程可分为3段，第(1)段必走，且必在早上游览。后两段请和随后的两条沟的行程自由组合。</p>
<p>（1）乘车）沟口 →（乘车）静海 →（徒步）箭竹海 →（徒步）熊猫海 →（徒步）五花海</p>
<p>在镜海拍照结束后，坐车到箭竹海，徒步箭竹海、箭竹海瀑布、熊猫海、熊猫海瀑布、五花海这几个景点。全程大概3.5km，耗时约2小时。如果你7点半进沟，10点左右应该就能结束这段了。这段应该算是日则沟的核心，必玩。</p>
<p>（2）之后可坐车至原始森林，途中观赏天鹅海，芳草海。耗时约1小时。</p>
<p>（3）然后从原始森林坐车下至珍珠滩，从珍珠滩到镜海这段，风景也很不错，徒步大概1小时左右，到达镜海停车场坐车至诺日朗。上午行程结束。诺日朗午餐之后，可顺路游览诺日朗瀑布，之后乘车游览则查洼沟。（乘车）五花海 →（乘车）原始森林→（徒步）珍珠滩 →（徒步）静海 →（乘车）诺日朗</p>
<p><strong>2. 则查洼沟</strong></p>
<p>（乘车）诺日朗 → 长海 →（徒步）五彩池 →（乘车）诺日朗</p>
<p><strong>3. 树正沟</strong></p>
<p>树正沟全长约14公里，被誉为九寨沟的缩影，这里有神奇诡秘的海子、多姿多彩的滩流，还有栈桥点缀其间的群海和群瀑以及气势雄伟的大瀑布，非常值得花时间徒步游览。主要景点：芦苇海、盆景滩、树正景区（火花海、卧龙海、犀牛海、古磨房和树正瀑布）。</p>
<p>推荐浏览路线：从盆景滩至犀牛海，全程均可徒步栈道。栈道是绕着每个海子走的，有部分在公路边，部分在树林中，两侧风光各有千秋，全走下来路程也不近，所以建议分2段进行。第(1)段行程建议放在早上，第(2)段请按照各人情况选择，也可以在下午出沟前游览。</p>
<p>（1）早晨在沟口乘车直达犀牛海（上车记得告诉导游在犀牛海下车，一般导游不推荐在树正沟下车，告诉他日则沟已经玩过即可），8点钟在犀牛海观倒映，拍照，都非常安静。然后往下走栈道，游览老虎海，树正群海，瀑布，到达火花海。耗时约2小时。（乘车）沟口→ 犀牛海 →（徒步）老虎海 →（徒步）树正群海 →（徒步）火花海</p>
<p>（2）火花海徒步至盆景滩，然后在盆景滩乘车出沟。耗时约2小时。（盆景滩至沟口约5.8km，且没有太多景色可看，徒步请谨慎。（乘车）火花海 →（徒步）双龙海→（徒步）芦苇海 →（徒步）盆景滩 →（乘车）沟口</p>
<p>![image-20230418233029220](&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230418233029220.png)</p>
<p>![image-20230418233203635](&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230418233203635.png)</p>
<h5 id="川主寺"><a href="#川主寺" class="headerlink" title="川主寺"></a>川主寺</h5><h5 id="黄龙（一天）"><a href="#黄龙（一天）" class="headerlink" title="黄龙（一天）"></a>黄龙（一天）</h5><h5 id="牟尼沟风景区"><a href="#牟尼沟风景区" class="headerlink" title="牟尼沟风景区"></a>牟尼沟风景区</h5><h5 id="毕棚沟景区"><a href="#毕棚沟景区" class="headerlink" title="毕棚沟景区"></a>毕棚沟景区</h5><h5 id="四姑娘山景区（一天）"><a href="#四姑娘山景区（一天）" class="headerlink" title="四姑娘山景区（一天）"></a>四姑娘山景区（一天）</h5><h5 id="都姜堰"><a href="#都姜堰" class="headerlink" title="都姜堰"></a>都姜堰</h5><h5 id="成都远洋太古里（一天）"><a href="#成都远洋太古里（一天）" class="headerlink" title="成都远洋太古里（一天）"></a>成都远洋太古里（一天）</h5><h4 id="安排"><a href="#安排" class="headerlink" title="安排"></a>安排</h4><h5 id="day1-4月26"><a href="#day1-4月26" class="headerlink" title="day1(4月26):"></a>day1(4月26):</h5><p>19:55北京出发到郑州</p>
<h5 id="day2-4月27"><a href="#day2-4月27" class="headerlink" title="day2(4月27):"></a>day2(4月27):</h5><p>08:00从郑州出发，11点36到达广元；广元到九寨沟的车最迟是12:00，</p>
<p>晚上住宿九寨沟沟口</p>
<h5 id="day3-4月28-九寨沟"><a href="#day3-4月28-九寨沟" class="headerlink" title="day3(4月28):九寨沟"></a>day3(4月28):九寨沟</h5><h6 id="门票：220元，环保车90元，7点进景区"><a href="#门票：220元，环保车90元，7点进景区" class="headerlink" title="门票：220元，环保车90元，7点进景区"></a>门票：220元，环保车90元，7点进景区</h6><h6 id="食宿：九寨沟盒饭2份，晚上入住川主寺镇"><a href="#食宿：九寨沟盒饭2份，晚上入住川主寺镇" class="headerlink" title="食宿：九寨沟盒饭2份，晚上入住川主寺镇"></a>食宿：九寨沟盒饭2份，晚上入住川主寺镇</h6><h6 id="交通：私家车或者景区车到川主寺"><a href="#交通：私家车或者景区车到川主寺" class="headerlink" title="交通：私家车或者景区车到川主寺"></a>交通：私家车或者景区车到川主寺</h6><h5 id="day4-4月29-黄龙-达古冰川"><a href="#day4-4月29-黄龙-达古冰川" class="headerlink" title="day4(4月29):黄龙+达古冰川"></a>day4(4月29):黄龙+达古冰川</h5><h6 id="门票：黄龙170，远古冰川200"><a href="#门票：黄龙170，远古冰川200" class="headerlink" title="门票：黄龙170，远古冰川200"></a>门票：黄龙170，远古冰川200</h6><h6 id="食宿：黑水县（离远古冰川近）"><a href="#食宿：黑水县（离远古冰川近）" class="headerlink" title="食宿：黑水县（离远古冰川近）"></a>食宿：黑水县（离远古冰川近）</h6><h6 id="交通：私家车或者景区大巴"><a href="#交通：私家车或者景区大巴" class="headerlink" title="交通：私家车或者景区大巴"></a>交通：私家车或者景区大巴</h6><h5 id="day5-4月30-达古冰川"><a href="#day5-4月30-达古冰川" class="headerlink" title="day5(4月30):达古冰川"></a>day5(4月30):达古冰川</h5><h6 id="门票-观光车"><a href="#门票-观光车" class="headerlink" title="门票+观光车"></a>门票+观光车</h6><h6 id="食宿：住汶川县或者lixin（bi"><a href="#食宿：住汶川县或者lixin（bi" class="headerlink" title="食宿：住汶川县或者lixin（bi"></a>食宿：住汶川县或者lixin（bi</h6><h6 id="交通：私家车或者"><a href="#交通：私家车或者" class="headerlink" title="交通：私家车或者"></a>交通：私家车或者</h6><h5 id="day6-5月01-毕棚沟-回成都"><a href="#day6-5月01-毕棚沟-回成都" class="headerlink" title="day6(5月01):毕棚沟+回成都"></a>day6(5月01):毕棚沟+回成都</h5><h6 id="门票-观光车-4-5小时"><a href="#门票-观光车-4-5小时" class="headerlink" title="门票+观光车 4-5小时"></a>门票+观光车 4-5小时</h6><h6 id="食宿：住成都"><a href="#食宿：住成都" class="headerlink" title="食宿：住成都"></a>食宿：住成都</h6><h6 id="交通：私家车或者-1"><a href="#交通：私家车或者-1" class="headerlink" title="交通：私家车或者"></a>交通：私家车或者</h6><p>到成都吃</p>
<h5 id="day7-5月02-成都"><a href="#day7-5月02-成都" class="headerlink" title="day7(5月02):成都"></a>day7(5月02):成都</h5><p>在市里逛吃逛吃</p>
<h5 id="day8-5月03-成都"><a href="#day8-5月03-成都" class="headerlink" title="day8(5月03):成都"></a>day8(5月03):成都</h5><p>回北京继续搬砖，等待后面的泰国之行，还有更后面的长沙吃喝</p>
<h5 id="备选：-四姑娘山"><a href="#备选：-四姑娘山" class="headerlink" title="备选： 四姑娘山"></a>备选： 四姑娘山</h5><p>四姑娘山：双桥沟80+70，长坪沟72+20，海子沟60；建议游玩半天到一天</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>理论上，住沟内属于非法行为，因为可以逃票。据网上各种<a href="https://www.yunliebian.com/siyu/siyu-36.html">攻略</a>介绍，主要是住在树正寨和则查寨的藏民家，150-200元&#x2F;人，即使被抓只是补交90元的观光车票。</li>
<li>强烈推荐早上7点进沟，可以独享九寨美景。静静地沉浸在如梦如幻的湖光山色中，周围没有嘈杂的各种拗造型的叽叽歪歪，那种感觉是不能用语言来形容的</li>
<li>泳衣</li>
<li></li>
</ul>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>财务bp整理</title>
    <url>/2022/03/02/%E8%B4%A2%E5%8A%A1/%E8%B4%A2%E5%8A%A1pb%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>Q：预测和实际的直接差异，作为bp你怎么做</p>
<p>A：月初收到业务的报表时将费用和预算做一个比较分析，一般是以10%作为分界点，如果费用没有超过预算10%，问下业务超预算原因并做出提示；如果实际花费超过预算的10%，需要业务发邮件至EMT成员审批，EMT成员审批完成后方可对费用进行审批</p>
<p>Q：预算的编制环节，怎么监控预算，滚动预算是怎么编制的</p>
<p>A：1、预算的编制我理解是业务根据去年的实际业务量根据自己今年的规划按照一定的比例测算出今年的业务量，再根据业务量的变动测算出实际的花费情况，报经领导审批后发送财务部，财务部选择器关键指标编制预算</p>
<p> 2、预算监控，我理解是回到问题1上面了</p>
<p> 3、滚动预算编制的话，Q4开启下一年的预算工作，编制完预算后后，一般不轻易改动预算，如果有重大性质发生变化后，（月度滚动预算不懂） </p>
<p>Q：作为财务bp，事前的管理是怎么管理的</p>
<p>这道题不知道问什么</p>
<span id="more"></span>

<p>Q：合同审批</p>
<p>A:合同审批上主要注重的点是：结算逻辑、结算条款、结算周期、关注合同的实质，了解合同中实际的业务情况，验收标准，合同的主体和供应商信息</p>
<p>Q：分析是怎么分析的</p>
<p>A：分析主要：1、比较分析：我这边费用会采用本期与上期的比较来确定费用的发生情况</p>
<p>​       2、比率分析：征信费会看一些比率，通过征信费&#x2F;放款金额，或征信费&#x2F;授信数量来确定比率，从而与预算做对比进行分析，如果举例怎么办？</p>
<p>Q：你做分析有什么亮点？</p>
<p>  这个完全不懂，只说了会用图表的形式做一个更直观的展示</p>
<p>Q：离职原因</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/image-20220302183159011.png" alt="image-20220302183159011"></p>
]]></content>
      <categories>
        <category>gf</category>
      </categories>
      <tags>
        <tag>财务</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2022/03/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/mysql/mysql/</url>
    <content><![CDATA[<p>磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1&#x2F;120&#x2F;2 &#x3D; 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 &#x3D; 9ms左右，听起来还挺不错的，但要知道一台500 -MIPS的机器每秒可以执行5亿条指令，因为指令依靠的是电的性质，换句话说执行一次IO的时间可以执行40万条指令，数据库动辄十万百万乃至千万级数据，每次9毫秒的时间，显然是个灾难。<span id="more"></span>下图是计算机硬件延迟的对比图，供大家参考：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/otwuSOQftUPj0ibyib6t0DGdiacuGpWzWx5mUJFMBObP6JXBFnd0icQQhib0WXm4wPTTBQlXq6SNeNzMxdbswicGPTaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>various-system-software-hardware-latencies</p>
<p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。[copy]</p>
<p><strong>Mysql server</strong></p>
<p>链接器、分析器、优化器、执行器</p>
<p><strong>储存引擎</strong></p>
<p>mysq的存储引擎主要有innodb(B+)、myisam（B+)、memory(哈希）</p>
<p>memory 基于内存的最快</p>
<table>
<thead>
<tr>
<th>innodb</th>
<th>myisam</th>
</tr>
</thead>
<tbody><tr>
<td>支持事务</td>
<td>不支持事务</td>
</tr>
<tr>
<td>支持表锁、行所</td>
<td>只支持表锁</td>
</tr>
<tr>
<td>数据文件和索引文件不分开，元信息文件</td>
<td>数据文件和索引文件分开，元信息文件</td>
</tr>
<tr>
<td>直接可以count(*)</td>
<td>需要统计</td>
</tr>
<tr>
<td>叶子节点的键值域，值域保存数据</td>
<td>叶子节点的键值域，值域保存指针</td>
</tr>
<tr>
<td>支持外键</td>
<td>不支持外键</td>
</tr>
<tr>
<td>大量update、insert、delete</td>
<td>大量select</td>
</tr>
</tbody></table>
<ul>
<li><p>表默认是innodb，innodb在没有显示定义主键的时候，引擎会自动定义一个rowid作为主键。</p>
</li>
<li><p>myisam内部有个一auto_incrment的内部列，当插入或者更新该列的时候，这个内部列也会更新，这个列的更新比innoddb的autoz_incrment快</p>
</li>
<li><p>如何选择</p>
</li>
<li><ul>
<li>myisam性能更高，占用的内存更少，并且索引和数据分开的，索引是经过压缩的，节省内存并且查找也快，适用于查询大的情况。</li>
<li>innodb支持事务，对多并发的情况，用innodb。</li>
</ul>
</li>
</ul>
<p><strong>索引</strong></p>
<ol>
<li><p>mysql的索引:主要B数、B+树和哈希(memory)</p>
</li>
<li><p>B数非叶子节点不仅有n-1个key(不仅有索引值，还有data域的数据值）节点，还n个point 节点；叶子节点的指针都为空。</p>
</li>
<li><p>B+树非叶子节点只有索引字段节点和指针节点，都是N个；其中叶子节点没有指针域，只有键值域（索引键和记录域）【上层的节点会在下层都出现的】</p>
</li>
<li><p>索引分类：主键索引（不允许重复、不允许为空）、唯一索引（不允许重复，可以为空）、普通索引（允许空）、全文索引、组合索引（多个列中的值不允许有空值，最左匹配原则）</p>
</li>
<li><p>索引原则：</p>
</li>
<li><ol>
<li>最左匹配</li>
<li>&#x3D;和in可以乱序使用</li>
<li>尽量选择区分度高的列作为索引</li>
<li>对索引不要进行计算，计算结果和索引完全是不一样的结果，检索成本高</li>
<li>尽量扩展索引，不要新建索引</li>
</ol>
</li>
<li><p>索引的优缺点：</p>
</li>
<li><ol>
<li>优点：加快检索和查询的所读，减少io的次数</li>
<li>缺点：索引表也是表，会占用存储空间，大概是数据表的1.5倍。索引需要占用<strong>磁盘空间</strong>，因此在创建索引时要考虑到磁盘空间是否足够;创建索引时需要对表加锁，因此实际操作中需要在业务空闲期间进行</li>
</ol>
</li>
<li><p>聚集索引和非聚集索引:</p>
</li>
<li><ol>
<li>聚集索引：代表innodb，它是主键索引的键值对域（节点）的主键和值（数据）放在叶子节点；辅助索引键值对域（节点）的辅助键和值（主键索引的键）放在叶子节点；最好按照自增的键来插入，否则会引起索引的分裂，也就是磁盘页的分裂，增加维护开销；</li>
<li>非聚集索引：代表myisam,他是主键索引的索引键和值（记录）分开的一种；主键索引和辅助索引是两种索引，除了数据（记录）没有其他关系；只是主索引不允许重复，不允许空值，他们的叶子结点的key都存储指向键值对应的数据的物理地址。</li>
<li><img src="https://mmbiz.qpic.cn/mmbiz_jpg/otwuSOQftUPj0ibyib6t0DGdiacuGpWzWx5ckQSewJt4exF60oOE2NbAwtqcjH12z8WN5pl0se1AbP644HTfMTNfQ/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></li>
</ol>
</li>
<li><p>注意点：</p>
</li>
<li><ol>
<li><p>回表-innodb，先查辅助索引，在通过主键索引找到数据【解决–简历包含的联合索引】</p>
</li>
<li><p>索引下推–新版本的功能，联合索引的所有字段都会比较；之前是只比价第一个</p>
</li>
<li><p>最左匹配原则【列字段最左，某个字段最左边的字符】</p>
</li>
<li><p>InnoDB的二级索引带来的好处就是<strong>减少了由于数据移动或者数据页分列导致行数据的地址变了而带来的维护二级索引的性能开销，因为InnoDB的二级索引不需要更新行指针</strong></p>
</li>
</ol>
</li>
</ol>
<p><strong>事务</strong></p>
<ol>
<li><p>特性</p>
</li>
<li><ol>
<li>Atomicity（原子性）：不能再分割，最小单元，undo log（执行跟用户相反的操作，类似回溯）</li>
<li>Consistency(一致性）：一个状态到另一个状态</li>
<li>isolation（隔离性）：一个事务做的可能改变，对其他事务来说不可以见，注意这里的“通常来说”，后面的事务隔离级级别会说到（锁），通常指事务的隔离性。【mvcc多版本并发控制】</li>
<li>Duration（持久性）：做的操作不丢失。redo log</li>
</ol>
</li>
<li><p>特性的解决方案：</p>
</li>
<li><ol>
<li>隔离性是通过锁或者mvcc解决的</li>
<li>其他是通过事务日志实现</li>
</ol>
</li>
<li><p>隔离级别</p>
</li>
<li><ol>
<li>读未提交：一个事务修改了某个记录，但是在未提交前被另一个事务读取到了；</li>
<li>读提交：读取别的事务已经提交的数据，不能重复读</li>
<li>可重复读：</li>
<li>串行化</li>
</ol>
</li>
<li><p>并发带来的问题：</p>
</li>
<li><ol>
<li>更新丢失（数据丢失）：两个人同时修改，一个数据覆盖另一个数据</li>
<li>脏读：一个事务在修改数据期间，另一个事务读取了这部分修改不完全的数据，这部分数据就是脏读。</li>
<li>不可重复读：一个事务在读取周期内，两次读取数据后，发现读取到的数据不一致；因为第二个事务在这期间对数据做了修改；侧重修改</li>
<li>幻读：一个事务读取了数据（大量的），然后另一个事务插入或者删除了数据，第一个事务重新读的时候发现结果不一致；侧重新增或者删除</li>
</ol>
</li>
<li><p><img src="https://mmbiz.qpic.cn/mmbiz_png/otwuSOQftUPD2XBzj2CYicDexzZibJVs6KuBxhCOvgzPPXMvfgHMpmibCqOz0qCk0G69kMdLE3lIjUricrJUHCajicw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
<li><p>mvcc解决读提交和重复读,可能解决幻读的问题。</p>
</li>
</ol>
<p><strong>主从复制</strong></p>
<ol>
<li><p>binlog 的三种模式：statement、row和mix</p>
</li>
<li><p>MySQL的主从复制和读写分离两者有着紧密的联系，首先要部署主从复制，只有主从复制完成了才能在此基础上进行数据的读写分离。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/otwuSOQftUPD2XBzj2CYicDexzZibJVs6KfKoP6niaaQuRbmGCaWl9NOfw7O6jibLdG0xesMzWY7KGqLibKBuQ2icicYQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
<li><p>复制过程：前提是主节点开启了binlog同步，master有更新的时候，也会把更新写到binlog中；首先salve创建io线程请求连接master，这时候主节点会创建一个dump log 的线程，这个线程将最新的binlog数据传给salve，salve会将数据写到relay log中，再有sql线程将中继日志写入salve库</p>
</li>
<li><p><img src="https://mmbiz.qpic.cn/mmbiz_png/otwuSOQftUPD2XBzj2CYicDexzZibJVs6KKTd3KibzCujfy7QWIogyVGRkdZwjEGXo7eBR4LQqBQmPRTIFCf8LRSw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
<li><p>同步过程中会有同步延迟</p>
</li>
</ol>
<p><strong>读写分离</strong></p>
<ol>
<li>实现MySQL读写分离的前提是我们已经将MySQL主从复制配置完毕，读写分离实现方式：（1）配置多数据源。（2）使用mysql的proxy中间件代理工具。</li>
<li>主库负责读写</li>
<li>读库只负责读</li>
<li>xxx</li>
</ol>
<p><strong>分库分表</strong></p>
<ol>
<li><p>分表</p>
</li>
<li><ol>
<li><p>首先为什么要分表？（1） 如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I&#x2F;O操作 （2）如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响查询的性能。（3）表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。（4） 分表技术有(水平分割和垂直分割)</p>
</li>
<li><h4 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h4><p>垂直分割是指数据表列的拆分，把一张列比较多的表拆分为多张表。垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。</p>
<p>垂直分割比较常见：例如博客系统中的文章表，比如文章tbl_articles (id, titile, summary, content, user_id, create_time)，因为文章中的内容content会比较长，放在tbl_articles中会严重影响表的查询速度，所以将内容放到tbl_articles_detail(article_id, content)，像文章列表只需要查询tbl_articles中的字段即可。</p>
<p>垂直拆分的优点：可以使得行数据变小，在查询时减少读取的Block数，减少I&#x2F;O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p>垂直拆分的缺点：主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。</p>
</li>
<li><h4 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h4><p>水平拆分是指数据表行数据的拆分，表的行数超过500万行或者单表容量超过10GB时，查询就会变慢，这时可以把一张的表的数据拆成多张表来存放。水平分表尽可能使每张表的数据量相当，比较均匀。</p>
<p>水平拆分会给应用增加复杂度，它通常在查询时需要多个表名，查询所有数据需要union操作。在许多数据库应用中，这种复杂性会超过它带来的优点。</p>
<p>因为只要索引关键字不大，则在索引用于查询时，表中增加2-3倍数据量，查询时也就增加读一个索引层的磁盘次数，所以水平拆分要考虑数据量的增长速度，根据实际情况决定是否需要对表进行水平拆分。</p>
<p>水平分割最重要的是找到分割的标准，不同的表应根据业务找出不同的标准</p>
<p>用户表可以根据用户的手机号段进行分割如user183、user150、user153、user189等，每个号段就是一张表。</p>
<p>用户表也可以根据用户的id进行分割，加入分3张表user0,user1,user2，如果用户的id%3&#x3D;0就查询user0表，如果用户的id%3&#x3D;1就查询user1表。</p>
<p>对于订单表可以按照订单的时间进行分表。</p>
</li>
</ol>
</li>
<li><p>分库</p>
</li>
<li><ol>
<li>现在市面上主要的分库分表技术有mycat和sharding-jdbc</li>
</ol>
</li>
</ol>
<p><strong>锁</strong></p>
<ol>
<li>乐观锁和悲观锁</li>
</ol>
<p><strong>mvcc</strong></p>
<ol>
<li>xxxx</li>
<li>xxxx</li>
<li>xx</li>
</ol>
<p><strong>日志系统</strong></p>
<ol>
<li>xxx</li>
<li>xxx</li>
</ol>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka概念</title>
    <url>/2022/02/17/%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/kafka/</url>
    <content><![CDATA[<ul>
<li><p>ISR、OSR、AR</p>
<ul>
<li>ISR：In-Sync Replicas 副本同步队列</li>
<li>OSR：Out-of-Sync Replicas</li>
<li>AR：Assigned Replicas 所有副本</li>
<li>ISR是由leader维护，follower从leader同步数据有一些延迟（具体可以参见 图文了解 Kafka 的副本复制机制），超过相应的阈值会把 follower 剔除出 ISR, 存入OSR（Out-of-Sync Replicas ）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR。</li>
</ul>
</li>
<li><p>Kafka的日志目录结构</p>
<ul>
<li><p>每个partition一个文件夹，包含四类文件.index .log .timeindex leader-epoch-checkpoint</p>
<span id="more"></span>
</li>
<li><p>.index .log .timeindex 三个文件成对出现，前缀为上一个segment的最后一个消息的偏移；log文件中保存了所有的具体消息；index文件中保存了稀疏的相对偏移的索引；timeindex保存的则是时间索引；通过2分查找；</p>
<table>
<thead>
<tr>
<th>offset1</th>
<th>消息在log中的物理磁盘偏移1</th>
</tr>
</thead>
<tbody><tr>
<td>offset2</td>
<td>消息在log中的物理磁盘偏移2</td>
</tr>
</tbody></table>
</li>
<li><p>leader-epoch-checkpoint中保存了每一任leader开始写入消息时的offset 会定时更新 follower被选为leader时会根据这个确定哪些消息可用</p>
</li>
</ul>
</li>
<li><p>Kafka的control</p>
<ul>
<li>作用：通过zookeeper管理和协调整个kafka集群</li>
<li>选择：第一个在zk上创建临时节点的broker，</li>
<li>功能：<ul>
<li>创建topic</li>
<li>分区重分配</li>
<li>preferred领导选举</li>
<li>集群成员管理</li>
<li>数据传输</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Kafka的特性:⾼吞吐量、低延迟，可扩展，持久性、可靠性，容错性，⾼并发kafka消息格式转换 只会在Broker端发⽣了消息格式转换。1.如果⽣产者 和 Kafka 集群版本的消息格式不⼀致，（因为在Kafka更新的过程中，进⾏了⼀次消息格式的修改，）那 么 Broker端为了兼容考虑， 会将⽣产者的消息格式修改为当前版本的消息格式， ⽽转换消息格式是必然涉及 解压缩 和 重压缩的2. 如果消费者版本和Kafka 集群版本不⼀致，那么Broker也会进⾏消息格式转换 在partition中如何通过offffset查找message1. 根据offffset ，⼆分查找⽂件列表，就可以快速定位到index⽂件（index⽂件采⽤稀疏索引存储⽅式）2. 根据offffset，定位到index的元数据物理位置和log的物理偏移地址3. 在稠密索引中，⽂件中的每个搜索码值都对应⼀个索引值，在稀疏索引中，只为索引码的某些值建⽴索引项。为什么 kafka 要⽤ page cache1. 如果使⽤ JVM 来管理这些内存 参考[1.a]1. 对象头会带来很多空间浪费 2. 过⼤的堆会让 JVM GC 负担太重, 影响回收效率 3. 当重启 kafka 服务时, 内存上重建缓存10GB 的告诉缓存可能需要很长时间 参考[1]1. ⽽使⽤ page cache , 即使重启 kafka 也能够直接利⽤其中的缓存 2. 使⽤ page cache 的另外⼀个好处就是可以使⽤ Zero-Copy 零拷贝 1. zero-copy 可以降低系统调⽤的次数 (减少内核态&#x2F;⽤户态上下⽂切换) 2. 可以减少在不同缓冲区之间的 copying3. 如果Kafka producer的⽣产速率与consumer的消费速率相差不⼤，那么就能⼏乎只靠对broker page cache的 读写完成整个⽣产-消费过程, 所有的数据都在内存中,这是 kafka 的⾼吞吐量的保证 参考[2.a]4. 这也是⼀个权衡的⽅案, 能够在开发量适当的情况下, 尽可能地提⾼IO效率 参考[5.a]关于零拷贝：producer⽣产消息时，会使⽤pwrite()系统调⽤【对应到Java NIO中是FileChannel.write() API】按偏移量写⼊数据，并 且都会先写⼊page cache⾥。consumer消费消息时，会使⽤sendfifile()系统调⽤【对应FileChannel.transferTo()API】，零拷贝地将数据从page cache传输到broker的Socket buffffer，再通过⽹络传输。注意事项：1. 对于单纯运⾏Kafka的集群⽽⾔，⾸先要注意的就是为Kafka设置合适（不那么⼤）的JVM堆⼤⼩。从上⾯的分析可 知，Kafka的性能与堆内存关系并不⼤，⽽对page cache需求巨⼤。根据经验值，为Kafka分配5~8GB的堆内存就已经⾜ ⾜够⽤了，将剩下的系统内存都作为page cache空间，可以最⼤化I&#x2F;O效率。2. 另⼀个需要特别注意的问题是lagging consumer，即那些消费速率慢、明显落后的consumer。它们要读取的数据 有较⼤概率不在broker page cache中，因此会增加很多不必要的读盘操作。⽐这更坏的是，lagging consumer读取 的“冷”数据仍然会进⼊page cache，污染了多数正常consumer要读取的“热”数据，连带着正常consumer的性能变差。在⽣产环境中，这个问题尤为重要。3. 同时如果有其他进程申请内存，会回收抢占⼀部分PageCache，但也会导致Kafka吞吐量下降会不稳定<a href="https://my.oschina.net/vivotech/blog/4524883https://giraffffetree.me/2020/11/16/Kafka-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98-page-cache/https://cloud.tencent.com/developer/article/1488144https://shiyueqi.github.io/2017/04/27/Kafka-Pagecache%E5%8E%9F%E7%90%86/kafka%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A71">https://my.oschina.net/vivotech/blog/4524883https://giraffffetree.me/2020/11/16/Kafka-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98-page-cache/https://cloud.tencent.com/developer/article/1488144https://shiyueqi.github.io/2017/04/27/Kafka-Pagecache%E5%8E%9F%E7%90%86/kafka如何保证可靠性1</a>. topic分区副本Kafka 可以保证单个分区⾥的事件是有序的，在众多的分区副本⾥⾯有⼀个副本是 Leader，其余的副本是 follower，所 有的读写操作都是经过 Leader 进⾏的，同时 follower 会定期地去 leader 上的复制数据。当 Leader 挂了的时候，其中 ⼀个 follower 会重新成为新的 Leader。通过分区副本，引⼊了数据冗余，同时也提供了 Kafka 的数据可靠性。2. Producer 往 Broker 发送消息根据实际的应⽤场景，我们设置不同的 acks，以此保证数据的可靠性。3. kafka副本同步机制<a href="https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650716970&amp;idx=1&amp;sn=3875dd83ca35c683bfa42135c55a03ab&amp;chksm=887da65cbf">https://mp.weixin.qq.com/s?__biz=MzA5MTc0NTMwNQ==&amp;mid=2650716970&amp;idx=1&amp;sn=3875dd83ca35c683bfa42135c55a03ab&amp;chksm=887da65cbf</a>  何时产⽣压缩 1. ⽣产者 为了数据在传输到 Kafka 可以更快， 那么在⽣产者启动压缩⾃然是很正常的。2. Broker端 Broker 主要是负责储存数据， 压缩能够很好的减少磁盘的占⽤。⼀般情况⽽⾔， 如果数据已经在 ⽣产 者端压缩了， 那么其实就不需要在Broker端再做处理， 实际上也确实是这样， 但是如果发⽣以下这些情况， 那么Broker端会再进⾏压缩， 这样⽆疑会导致性能问题， 所以应该尽量避免：Broker端指定了和Producer端不同的压缩算法， 这很好理解，因为压缩算法不⼀致， Broker 就需要解压 缩，并在此压缩成设定好的算法， 所以⼀定要避免这种情况。Broker端发⽣了消息格式转换。这⾥所谓的消息格式转换，是因为在Kafka更新的过程中，进⾏了⼀次消息格式的修改， 如果⽣产者 和 Kafka 集群版本的消息格式不⼀致， 那么 Broker端为了兼容考虑， 会将 ⽣产 者的消息格式修改为当前版本的消息格式， ⽽转换消息格式是必然涉及 解压缩 和 重压缩的， 何时解压缩？1. Consumer端 消费数据⾃然需要将数据解压缩，这个没什么好说的。2. Broker端 这⾥可能你要奇怪了， 为什么Broker端还要解压缩呢？实际上Broker端只是为了进⾏消息的校检， 以 保证数据的正确性， 这样必然会给Broker端的性能带来⼀定的影响， 但是就⽬前来说，好像也没什么好的解决办 法。当kafka遇到如下四种情况的时候，kafka会触发消费组Rebalance机制：1. 消费组成员发⽣了变更，⽐如有新的消费者加⼊了消费组组或者有消费者宕机 2. 消费者⽆法在指定的时间之内完成消息的消费 3. 消费组订阅的Topic发⽣了变化 4. 订阅的Topic的partition发⽣了变化kafka的zookeeper存储结构kafka的选举机制1. 控制器（Broker）选主1. 集群中第⼀个启动的broker会通过在zookeeper中创建临时节点&#x2F;controller来让⾃⼰成为控制器，其他broker启动 时也会在zookeeper中创建临时节点，但是发现节点已经存在，所以它们会收到⼀个异常，意识到控制器已经存在，那么 就会在zookeeper中创建watch对象，便于它们收到控制器变更的通知。2. 集群中每选举⼀次控制器，就会通过zookeeper创建⼀个 controller epoch ，每⼀个选举都会创建⼀个更⼤，包含最新信息的 epoch ，如果有broker收到⽐这个 epoch 旧的数据，就会忽略它们，kafka也通过这个 epoch 来防⽌集群产⽣“脑 裂”。3. 如果有⼀个broker加⼊集群中，那么控制器就会通过Broker ID去判断新加⼊的broker中是否含有现有分区的副本， 如果有，就会从分区副本中去同步数据。4. 如果集群中有⼀个broker发⽣异常退出了，那么控制器就会检查这个broker是否有分区的副本leader，如果有那么这个分区就需要⼀个新的leader，此时控制器就会去遍历其他副本，决定哪⼀个成为新的leader，同时更新分区的ISR集 合。5. 负责删除topic以及副本重分配2. 分区多副本选主 ⾸领副本（leader）：也就是leader主副本，每个分区都有⼀个⾸领副本，为了保证数据⼀致性，所有的⽣产者与消费者 的请求都会经过该副本来处理。跟随者副本（follower）：除了⾸领副本外的其他所有副本都是跟随者副本，跟随者副本不处理来⾃客户端的任何请求， 只负责从⾸领副本同步数据，保证与⾸领保持⼀致。如果⾸领副本发⽣崩溃，就会从这其中选举出⼀个leader。⾸选⾸领副本：创建分区时指定的⾸选⾸领。如果不指定，则为分区的第⼀个副本。1. 第⼀次选主，Kafka会将副本中清单AR⾥的第⼀个同步副本（preferred replica）选为⾸领2. 当主异常挂了，会从isr列表中选择⼀个作为主，如果isr列表⾥没有副本，那么检查是否允许允许脏主选举，允许的 话，会从ar列表⾥选择⼀个作为主3. 消费组选主在kafka的消费端，会有⼀个消费者协调器以及消费组，组协调器GroupCoordinator需要为消费组内的消费者选举出⼀ 个消费组的leader如果消费组内还没有leader，那么第⼀个加⼊消费组的消费者即为消费组的leader如果某⼀个时刻leader消费者由于某些原因退出了消费组，那么就会重新选举leader，map中的第⼀个消费者作为新的leaderkafka同步机制 写是都往leader上写，读也只在leader上读，flflower只是数据的⼀个备份，保证leader被挂掉后顶上来，并不往外提供 服务。Follower通过拉取的⽅式从Leader中同步数据。消费者和⽣产者都是从Leader中读取数据，不与Follower交互。利⽤ISR列表的机制实现了1. 当⼀个⽣产者要⽣产⼀个消息到topic中的某个partition中时，这条消息⾸先会被分区的leader副本追加到它的log中2. follower副本持续的从leader上拉去消息，follower从leader同步数据有⼀些延迟（超过延迟时间replica.lag.time.max.ms）后会被踢出ISR列表3. 每个follower都有⼀个LEO，取⼀个partition对应的ISR中最⼩的LEO作为HW，HW之后的数据消费者看不到，HW之 前的消息成为已提交的消息，HW也会持续的⼴播给followers，followers持久化到磁盘，恢复时⽤。4. 当⼀个失败的replica重启后，⾸先读取磁盘中的HW然后将log截断到HW，然后成为follower开始向leader拉去HW之 后的消息，⼀旦追赶上leader的LEO，这个replica⼜重新被加⼊到ISR<a href="https://javazhiyin.blog.csdn.net/article/details/115258060https://www.kancloud.cn/nicefo71/kafka/1470863https://www.jianshu.com/p/7008d2a1e320https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/distributed-system/messagequeue/Kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.md">https://javazhiyin.blog.csdn.net/article/details/115258060https://www.kancloud.cn/nicefo71/kafka/1470863https://www.jianshu.com/p/7008d2a1e320https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/distributed-system/messagequeue/Kafka%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.md</a></p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--hash</title>
    <url>/2022/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/noSql/redis--hash/</url>
    <content><![CDATA[<h6 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h6><p>redis的hash结构是指某个key对应的值是hash，值为key-value的形似；</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/hash111.jpg" alt="hash111"></p>
<span id="more"></span>

<p>(ps:图是盗取的）</p>
<p>其中ht是大小为2的指针数组，分表指向两个hashtable 表；当key发生冲突的时候，通过链地址法解决冲突，在dictEntry结构体中有节点的next指针，用来指向冲突的下一个节点，每次有新节点时，插在连表的头部。</p>
<p>redis哈希算法：使用了murmurhash2算法</p>
<p>rehash：</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/hash222.jpg" alt="hash222"></p>
<p>(ps:盗图）</p>
<p>其中rehash分为两种情况：扩容和缩容</p>
<p>rehash的限制：当在进行bgsave或者background时并且装载因子大于1时不进行rehash；</p>
<p>rehash条件：【扩容】当进行bgsave或者时并且装载因子大于5的时候进行rehash;正常情况是装载因子大于1就进行rehash（其中不包括在bgrewriteaof或者bgsava的；【缩容】：当hash因子是小于0.1（100个节点，不到10个在用）的时候，执行缩容</p>
<p>rehash的过程：是一种渐进式的hash过程，当rehashidx&#x3D;-1的时候不进行hash； </p>
<p>首先分配2的n次幂（刚大于已有的2倍）的大小；</p>
<p>其次从0开始，每rehash一个指针数组元素时。rehashidx就进行++操作</p>
<p>第三直到所有的节点都rehash 完，其中有size和sizemask；再讲rehashidx重置为-1；</p>
<p>最后将ht[0]指向新的hash表，ht[1]置为空</p>
<p>rehash时的增删改查：所有的增删改查都在新的hash表上进行，旧的hash表只是做迁移，将其节点链在指针数据下面。</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--主从复制</title>
    <url>/2022/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/noSql/redis--%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h6 id="旧版复制"><a href="#旧版复制" class="headerlink" title="旧版复制"></a><strong>旧版复制</strong></h6><ul>
<li><p>方式：salveof    ip   port</p>
</li>
<li><p>实现：同步和命令传播</p>
</li>
<li><p>同步：</p>
<ul>
<li>同步是从服务器像主服务器发送sync命令开始</li>
<li>主服务器接收到从服务器的的sync命令后，开始由子进程（bgsave)生成一个rdb文件，同时使用一个缓冲区记录现在开始写入的命令</li>
</ul>
</li>
<li><p>rdb写入完成后，由子进程发送rdb文件给从服务器,从服务器通过rdb更新这个从服务器的库至bgsave。</p>
</li>
<li><p>主服务器发送缓冲区里的的命令给从服务器，从服务器执行这些命令，达到和从服务器一样的状态</p>
</li>
<li><p>命令传播：主服务器会将所有的写命令发送给从服务器来达到主从一直的情况</p>
</li>
<li><p>缺陷：断线重连不能高效的完成，从服务器需要重新加载rdb文件</p>
</li>
</ul>
<span id="more"></span>

<h6 id="新版复制"><a href="#新版复制" class="headerlink" title="新版复制"></a><strong>新版复制</strong></h6><ul>
<li><p>方式：salveof  ip   port</p>
</li>
<li><p>实现：同步和命令传播</p>
</li>
<li><p>同步：完全重同步和部分重同步</p>
<ul>
<li><p>同步通过psync命令开始</p>
</li>
<li><p>完整重同步用于第一次同步，和旧版的同步一样。</p>
</li>
<li><p>部分重同步用于解决断线重连重新复制的低效问题。</p>
</li>
<li><p>从服务器发现自己掉线，发送psync</p>
<ul>
<li>接受continue，准备接受部分重同步</li>
<li>开始</li>
</ul>
</li>
<li><p>命令传播</p>
</li>
<li><p>命令传播</p>
</li>
</ul>
</li>
<li><p>缺陷：</p>
</li>
</ul>
<h6 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a><strong>部分重同步</strong></h6><ul>
<li>构成部分：复制偏移量、复制挤压缓冲区和服务器的运行id</li>
<li>同步过程：主从服务器都各自维护一个复制偏移量，主有个固定长度的复制挤压缓冲区队列</li>
<li>正常主服务器向从服务器发送N个字节时，主和从都会在偏移量上加N<ul>
<li>当断线后，从向主发送psync命令，并将自己的偏移量和服务运行id告诉主服务器，如果从服务器发送的运行id和当前的id一样，再根据偏移量来判断，主服务器发现这个偏移量在自己的缓冲区里面，就执行部分冲同步；不在就执行完全重同步；如果运行id不一样就执行完全重同步。</li>
<li>PSYNC命令的调用方法：从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令，主动请求主服务器 进行完整重同步（因为这时不可能执行部分重同步）。·相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时 将向主服务器发送PSYNC <runid> <offset>命令：其</li>
</ul>
</li>
</ul>
<h6 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a><strong>心跳检测机制</strong></h6><p>检查连接是否正常</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--哨兵</title>
    <url>/2022/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/noSql/redis--%E5%93%A8%E5%85%B5/</url>
    <content><![CDATA[<h6 id="目的"><a href="#目的" class="headerlink" title="目的"></a><strong>目的</strong></h6><p>解决主从挂了只能手动去拉起的问题，哨兵是redis高可用（ha)的方案。</p>
<h6 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a><strong>Sentinel</strong></h6><p>启动：sentinel是一个redis server，只是他有自己特有的代码，相当于一个定制化的redis，用于监控 </p>
<p>命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct redisCommand sentinelcmds[] = &#123;</span><br><span class="line">&#123;&quot;ping&quot;,pingCommand,1,&quot;&quot;,0,NULL,0,0,0,0,0&#125;, </span><br><span class="line">&#123;&quot;sentinel&quot;,sentinelCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0&#125;, </span><br><span class="line">&#123;&quot;subscribe&quot;,subscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0&#125;, </span><br><span class="line">&#123;&quot;unsubscribe&quot;,unsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0&#125;, </span><br><span class="line">&#123;&quot;psubscribe&quot;,psubscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">&#123;&quot;punsubscribe&quot;,punsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0&#125;, </span><br><span class="line">&#123;&quot;info&quot;,sentinelInfoCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0&#125; &#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sentinelState</span> &#123; </span><br><span class="line">    <span class="comment">// 当前纪元，用于实现故障转移 </span></span><br><span class="line">    <span class="type">uint64_t</span> current_epoch; </span><br><span class="line">    <span class="comment">// 保存了所有被这个sentinel 监视的主服务器 </span></span><br><span class="line">    <span class="comment">// 字典的键是主服务器的名字 </span></span><br><span class="line">    <span class="comment">// 字典的值则是一个指向sentinelRedisInstance 结构的指针 </span></span><br><span class="line">    dict *masters; <span class="comment">// 是否进入了TILT 模式？int tilt; </span></span><br><span class="line">    <span class="comment">// 目前正在执行的脚本的数量 </span></span><br><span class="line">    <span class="type">int</span> running_scripts;</span><br><span class="line">    <span class="comment">// 进入TILT 模式的时间 mstime_t tilt_start_time;</span></span><br><span class="line">    <span class="comment">// 最后一次执行时间处理器的时间 </span></span><br><span class="line">    <span class="type">mstime_t</span> previous_time; </span><br><span class="line">    <span class="comment">// 一个FIFO 队列，包含了所有需要执行的用户脚本 </span></span><br><span class="line">    list *scripts_queue; </span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">sentinelRedisInstance</span> &#123; </span><br><span class="line">    <span class="comment">// 标识值，记录了实例的类型，以及该实例的当前状态 </span></span><br><span class="line">    <span class="type">int</span> flags; </span><br><span class="line">    <span class="comment">// 实例的名字 </span></span><br><span class="line">    <span class="comment">// 主服务器的名字由用户在配置文件中设置 </span></span><br><span class="line">    <span class="comment">// 从服务器以及Sentinel 的名字由Sentinel 自动设置</span></span><br><span class="line">    <span class="comment">// 格式为ip:port ，例如&quot;127.0.0.1:26379&quot; </span></span><br><span class="line">    <span class="type">char</span> *name; <span class="comment">// 实例的运行ID char *runid;</span></span><br><span class="line">    <span class="comment">// 配置纪元，用于实现故障转移 </span></span><br><span class="line">    <span class="type">uint64_t</span> config_epoch; </span><br><span class="line">    <span class="comment">// 实例的地址 </span></span><br><span class="line">    sentinelAddr *addr; </span><br><span class="line">    <span class="comment">// SENTINEL down-after-milliseconds 选项设定的值 </span></span><br><span class="line">    <span class="comment">// 实例无响应多少毫秒之后才会被判断为主观下线（subjectively down ） mstime_t down_after_period; </span></span><br><span class="line">    <span class="comment">// SENTINEL monitor &lt;master-name&gt; &lt;IP&gt; &lt;port&gt; &lt;quorum&gt; 选项中的quorum 参数 </span></span><br><span class="line">    <span class="comment">// 判断这个实例为客观下线（objectively down ）所需的支持投票数量 </span></span><br><span class="line">    <span class="type">int</span> quorum; </span><br><span class="line">    <span class="comment">// SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt; 选项的值</span></span><br><span class="line">    <span class="comment">// 在执行故障转移操作时，可以同时对新的主服务器进行同步的从服务器数量 </span></span><br><span class="line">    <span class="type">int</span> parallel_syncs;</span><br><span class="line">    <span class="comment">// SENTINEL failover-timeout &lt;master-name&gt; &lt;ms&gt; 选项的值// 刷新故障迁移状态的最大时限 </span></span><br><span class="line">    <span class="type">mstime_t</span> failover_timeout; </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################### # master1 configure # #####################</span></span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">master1--&gt;name</span></span><br><span class="line">sentinel monitor master1 127.0.0.1 6379 2</span><br><span class="line">sentinel down-after-milliseconds master1 30000</span><br><span class="line">sentinel parallel-syncs master1 1</span><br><span class="line">sentinel failover-timeout master1 900000</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#################### # master2 configure # #####################</span></span></span><br><span class="line">sentinel monitor master2 127.0.0.1 12345 5 </span><br><span class="line">sentinel down-after-milliseconds master2 50000 </span><br><span class="line">sentinel parallel-syncs master2 5 </span><br><span class="line">sentinel failover-timeout master2 450000</span><br></pre></td></tr></table></figure>

<ul>
<li>配置含义<ul>
<li>down-after-milliseconds:redis server多少秒后无响应，代表主观下线</li>
<li>SENTINEL monitor <master-name> <IP> <port> <quorum>，quorum标识客观下线的票数</li>
</ul>
</li>
<li>创建连接<ul>
<li>命令连接：通过异步方式，命令连接用于向主服务器发送命令，并接主服务器的返回</li>
<li>订阅连接：异步，订阅主服务器的__sentinel__:hello频道【数据信息没有保存在内存中，所以要单独建立；通过订阅链接可以得知其他sentinel信息】</li>
</ul>
</li>
</ul>
<h6 id="Sentinel监控流程"><a href="#Sentinel监控流程" class="headerlink" title="Sentinel监控流程"></a><strong>Sentinel监控流程</strong></h6><ul>
<li><p>获取主服务器信息：sentinel每10s(秒）一次向主服务器发送info命令，sentinel根据返回信息能拿到主服务器和从服务器的信息。当sentinel根据当前保存的name【指定】信息能知道当前是否有新的从服务器，或者服务器是否重启了【主服务器是启动sentinel的时候手动配置的name等信息,主服务器实例结构的name属性的值是用户使用Sentinel配置文件设置的，而从服务器实 例结构的name属性的值则是Sentinel根据从服务器的IP地址和端口号自动设置的】。</p>
</li>
<li><p>获取从服务器信息：通过上一步得到从服务器信息的时候，sentinel会建立和从服务器的命令连接和订阅连接。之后以10s（秒）一次的频率向从服务发送info命令</p>
</li>
<li><p>发送信息：</p>
<ul>
<li>2s(秒)一次通过命令连接向主服务器和从服务器发送信息</li>
<li>PUBLISH <strong>sentinel</strong>:hello “<s_ip>,<s_port>,<s_runid>, <s_epoch>,<m_name>,<m_ip>,<m_port>,<m_epoch>“</li>
</ul>
</li>
<li><p>订阅信息：</p>
<ul>
<li>通过订阅链接订阅；SUBSCRIBE <strong>sentinel</strong>:hello</li>
<li>每个sentinel会根据频道获得其他sentinel的信息</li>
<li>Sentinel更新自己的sentinel 对象信息，如果存在更新；不存在新建。</li>
<li>创建向其他sentinel的命令链接</li>
</ul>
</li>
<li><p>检测主观下线：【领头sentinel】每秒向所有的主、从、sentinel 发送ping命令并根据得到的结果判断对应的实例是否在线。</p>
<ul>
<li>返回有效结果：+PONG、-LOADING、+MASTERDOWN的正常返回</li>
<li>其他为无效结果</li>
<li>如果在配置的下线时间内一直返回无效结果，则这个server对应的结构信息的flags设置为SIR_S_DOWN。</li>
<li>多个sentinel设置的主观下线的时间不一样</li>
</ul>
</li>
<li><p>检测客观下线流程：</p>
<ul>
<li>当一个sentinel （源）判断一个主服务器下线后，会向其他sentinel（目的）询问是否下线，发送以下命令<ul>
<li>eg1：SENTINEL is-master-down-by- addr <ip> <port> <current_epoch> <runid></li>
<li>eg2：SENTINEL is-master-down-by-addr 127.0.0.1 6379 0 *</li>
</ul>
</li>
<li>向源Sentinel返回一条包含三个参数 的Multi Bulk回复作为SENTINEL is-master-down-by命令的回复<down_state><leader_runid><leader_epoch>；eg:1  * 0</li>
<li>当Sentinel得到的下线回复数大于配置的quorum数的时候，将flags置为SIR_O_DOWN</li>
<li>每个sentinel对下线的认知不同，其实就是配置内容的配置项的不同（下线个数和时间）</li>
</ul>
</li>
</ul>
<h6 id="选举领头Sentinel"><a href="#选举领头Sentinel" class="headerlink" title="选举领头Sentinel"></a><strong>选举领头Sentinel</strong></h6><ul>
<li><p>背景：当sentinel发现一个server处于客观下线的时候，监视这个server的sentinel就会触发领头Sentinel选举</p>
</li>
<li><p>选举过程:参见raft</p>
</li>
</ul>
<h6 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a><strong>故障转移</strong></h6><ul>
<li><p>领头Sentinel挑选从下线主服务器的从服务器中挑选一个当做新的主服务器</p>
<ul>
<li><p>在下线主服务器的从服务器列表中删除已下线或者断开的从服务器项</p>
</li>
<li><p>删除最近5s(秒）内没有回复领头sentinel的从服务器</p>
</li>
<li><p>删除那些与主服务器连接断开超过down-after-milliseconds*10毫秒的从服务器</p>
</li>
<li><p>以上都是为了保证最新</p>
</li>
<li><p>将以上从服务器列表根据优先级进行排序，如果优先级一样；再按照偏移量进行排序(最大的偏移量）；否则根据运行id进行排序，最小的是最新的</p>
</li>
<li><p>领头Sentinel向被选中的从服务器发送salve of one,让其成为主服务器</p>
</li>
<li><p>领头Sentinel在故障迁移时以1s(秒）的频率发送info，检查role是否为master</p>
</li>
</ul>
</li>
<li><p>让下线主服务器的从服务器复制新的主服务器</p>
<ul>
<li>发送salveof命令复制新的主服务器</li>
</ul>
</li>
<li><p>如果这个下线主服务器重新上线，将（salveof)成为这个新主服务器的从服务器</p>
</li>
</ul>
<p>问题汇总：</p>
<p>哨兵节点挂了怎么办</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--基本数据结构</title>
    <url>/2022/02/24/%E4%B8%AD%E9%97%B4%E4%BB%B6/noSql/redis--%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><strong>redis五种基本数据结构</strong>：<strong>string、list、hash、set、zset</strong></p>
<p><strong>redis底层数据结构：简单动态字符串、双端连表、字典、压缩列表、整数集合</strong></p>
<h6 id="链表"><a href="#链表" class="headerlink" title="链表"></a><strong>链表</strong></h6><ol>
<li><p>代码定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">list</span>&#123;</span><br><span class="line">     <span class="comment">//表头节点</span></span><br><span class="line">     listNode *head;</span><br><span class="line">     <span class="comment">//表尾节点</span></span><br><span class="line">     listNode *tail;</span><br><span class="line">     <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">     <span class="comment">//节点值复制函数</span></span><br><span class="line">     <span class="built_in">void</span> (*free) (<span class="type">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值释放函数</span></span><br><span class="line">     <span class="built_in">void</span> (*free) (<span class="type">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值对比函数</span></span><br><span class="line">     <span class="built_in">int</span> (*match) (<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h6 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a><strong>跳跃表（跳表）</strong></h6><ol>
<li><p>效率：跳跃表效率和平衡二叉树一样</p>
</li>
<li><p>上层数据结构：有序集合、集群节点中用到了跳表</p>
</li>
<li><p>结构</p>
</li>
<li><ol>
<li>head：记录跳跃表的头结点；tail： 记录跳跃表的尾结点；level：记录最高层数;length：记录跳跃表节点个数。</li>
<li>zplist</li>
<li>zpnode</li>
</ol>
</li>
</ol>
<h6 id="整数集合（intset"><a href="#整数集合（intset" class="headerlink" title="整数集合（intset)"></a><strong>整数集合（intset)</strong></h6><ol>
<li>上层数据结构：集合键；前提：当元素都是整数，并且个数不多的时候使用</li>
<li>升级：扩大数据的类型，就是扩容保证有更大的元素能放下。</li>
<li>降级：不存在的</li>
<li></li>
</ol>
<h6 id="压缩链表（ziplist"><a href="#压缩链表（ziplist" class="headerlink" title="压缩链表（ziplist)"></a><strong>压缩链表（ziplist)</strong></h6><ol>
<li><p>效率：</p>
</li>
<li><p>上层数据结构：哈希键和列表键的底层数据结构</p>
</li>
<li><ol>
<li><p>哈希键：当键值对数量较少(hash的kv个数，下同），并且都是整型或者较短的字符串。</p>
</li>
<li><p>图示</p>
</li>
<li><ol>
<li><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/zlist.jpg" alt="zlist"></li>
<li><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/ziplist.jpg" alt="ziplist"></li>
<li></li>
</ol>
</li>
<li></li>
<li><p>结构：</p>
</li>
<li><ol>
<li><p>zlbyte:压缩列表的的长度</p>
</li>
<li><p>zltail:压缩列表到尾结点的长度</p>
</li>
<li><p>zllen:压缩列表节点的数量</p>
</li>
<li><p>entryX:节点对象</p>
</li>
<li><ol>
<li>prev_length表示上一个节点的长度【大小占1字节或者5字节，5字节时，第一个字节为0xFE;其他为】</li>
<li>encodeing表示类型和长度，本身占的大小有1个字节、2个字节和5个字节；</li>
</ol>
</li>
<li><p>zlend 特殊值（0xFF)</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h6 id="字典（hash）"><a href="#字典（hash）" class="headerlink" title="字典（hash）"></a><strong>字典（hash）</strong></h6><ol>
<li>单独章节</li>
</ol>
<h6 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a><strong>对象结构</strong></h6><ol>
<li><p>分类：字符串对象、列表对象、哈希对象、集合对象和有序集合对象</p>
</li>
<li><p>代码结构</p>
</li>
<li><pre><code class="c++">typedef struct redisObject &#123; 
// 类型 
unsigned type:4; 
// 编码 
unsigned encoding:4; 
// 指向底层实现数据结构的指针 
void *ptr;
//对象的引用计数
int refcount;
//对象最后访问的时间
unsigned lur;
&#125; obj;
</code></pre>
</li>
<li><ol>
<li><p>encoding 表示对象用什么底层数据结构来实现的</p>
</li>
<li><table>
<thead>
<tr>
<th>编码常量</th>
<th>底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_ENCODING_INT</td>
<td>long</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>emb的简单string[sds](小于32字节）</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态string</td>
</tr>
<tr>
<td>REDIS_ENCODING_ht</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_list</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_intset</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_skiplist</td>
<td>跳跃表</td>
</tr>
<tr>
<td>REDIS_ENCODING_zplist</td>
<td>压缩列表</td>
</tr>
</tbody></table>
</li>
<li><p>字符串使用：int、raw、embstr；embstr适用于短字符串类型</p>
</li>
<li></li>
</ol>
</li>
<li><p>内存回收：给对象建一个引用计数，通过引用计数来确定</p>
</li>
<li><p>对象共享：会有一些常量的对象被所有的命令共享</p>
</li>
</ol>
<p>总结：</p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/list.png" alt="list"></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/hash.png" alt="hash"></p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/set.png" alt="set"></p>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/zset.png" alt="zset"></p>
<h6 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a><strong>过期删除策略</strong></h6><ol>
<li><p>定时删除：在设置键的过期时间的时候，设置定时器，当过期时间快到的时候，删除过期键</p>
</li>
<li><p>定期删除：每隔一段时间就数据库进行遍历，删除里面的过期键。至于扫描策略，由算法定【每次遍历16个库，每个库20个元素，这过程是有时间限制的】。</p>
</li>
<li><p>惰性删除：当再次获取该key的时候根据是否过期来进行是否删除</p>
</li>
<li><p>主服务器在rbd、aof持久化的时候，都会删除过期键；主服务器在载入rdb（增加del命令）和aof的时候，都会删除过期键；从服务器在载入rdb文件的时候不会删除过期键，全部载入；但是在主从同步的时候，会清空从库，没啥影响；在复制的过程中，只有主服务器显示的给从服务器发送del命令的时候，从才会删除；所以在没有删除的瞬间，客户端访问从服务器，主从会得到不一样的结果。</p>
</li>
<li><p>同时使用两种持久化**</p>
<h6 id="redis淘汰策略"><a href="#redis淘汰策略" class="headerlink" title="redis淘汰策略"></a>redis淘汰策略</h6></li>
</ol>
<ul>
<li><p>noevication 不使用任何淘汰策略，超过限制时返回错误</p>
</li>
<li><p>allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键</p>
</li>
<li><p>volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键</p>
</li>
<li><p>allkeys-random：加入键的时候如果过限，从所有key随机删除</p>
</li>
</ul>
<p>  \5. volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐</p>
<p>  \6. volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键</p>
<p>  \7. volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</p>
<p>  \8. allkeys-lfu：从所有键中驱逐使用频率最少的键</p>
<p>redis-hash<br>redis-zset</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--持久化</title>
    <url>/2022/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/noSql/redis--%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>Redis持久化分为两种：第一种是rdb(redis database);第二种是aof（append only file);</p>
<h6 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h6><p>RDB 是一个二进制文件，可以压缩也可以不压缩</p>
<p>持久化的方式：手动save和自动bgsave</p>
<p>持久化的过程：手动save使redis服务器被hang住，不接受客户端的命令，直到save结束；bgsave可以手动触发，也可以通过配置特定的条件触发，比如：60s内执行了1000次命令；900s内执行了1次命令；bgsave是background save，在后台执行，通过子进程的方式</p>
<p>持久化文件的加载：在启动redis的加载rdb文件，在没有开启aof的时候，默认是开始加载rdb文件，没有特别的命令支持加载rdb</p>
<p>限制：在bgsave期间不执行其他客户端发来的save和bgsave;</p>
<table>
<thead>
<tr>
<th>REDIS</th>
<th>过期时间</th>
<th>key</th>
<th>type</th>
<th>编码类型的value</th>
</tr>
</thead>
</table>
<p>注解：文件检验和是个好东西</p>
<span id="more"></span>

<h6 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h6><p>AOF是保存所有执行的redis命令</p>
<p>持久化的条件：在配置中开启aof选项，选项为appendonly no&#x2F;yes;当开启aof的时候优先加载aof；</p>
<p>aof持久化的方式：通过配置的形式自动化的同步，比如选项：appendsync:awalys&#x2F;everysec;或者客户端通过bgrewrite命令进行</p>
<p>持久化的过程：将命令追加到aof buf里面，经过everysec 后flush到磁盘</p>
<p>限制：文件会过大</p>
<p>rewrite:存在aof文件过大，需要手动bgrewrite进行持久化或者通过aof percent 或者aof size 来进行自动同步；</p>
<p>在rewrite的开启一个没有网络链接的伪客户端，创建一个新文件，按照redis当天数据以命令的形势写如文件，同时开启一个aof 重写buf空间，保存在重新的过程中的这部分数据，当 当前redis的数据已经写入新aof文件后，我们就把aof重写buf空间的数据写入新的aof文件，然后原子的mv新的文件到旧文件。</p>
<p>对比：rdb的一致性比aof的高；rdb一般适合做永久备份，大规模的数据备份；在同步aof重写buf的之前，子进程会发信号给主进程，主进程会阻塞一下，导致redis服务器临时hold一下；fork子进程的时候也会hold子进程；重命名aof也会阻塞主进程</p>
<p>bgrewrite手动触发和自动触发【通过当前的大小和比例】</p>
<h6 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h6><p>rdb的优点：适合大规模的数据备份，灾难恢复；二进制文件相对aof较小；rdb在备份和恢复的时候相对更稳定。</p>
<p>rdb的缺点：出现故障的时候容易丢数据，数据的完整性和一致性的更低</p>
<p>aof的有点：完整性和一致性相对较高， redis-check-aof 可以修复异常的aof文件；最多丢失1秒的数据</p>
<p>aof的缺点：文件越来越大，需要重写；写的速度慢于rdb;</p>
<p>同时使用两种持久化，新持久化的时候是复制之前的临时文件。</p>
<p>持久化的格式</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--集群</title>
    <url>/2022/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/noSql/redis--%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h6 id="节点"><a href="#节点" class="headerlink" title="节点"></a><strong>节点</strong></h6><ul>
<li><p>定义：每一个redis server当做是一个集群的节点</p>
</li>
<li><p>启动：在配置文件中通过cluster_enabled为yes</p>
</li>
<li><p>添加方式：cluster meet ip port（copy）</p>
<ul>
<li><p>节点A会为节点B创建一个clusterNode结构，并将该结构添加到自己的 clusterState.nodes字典里面。2）之后，节点A将根据CLUSTER MEET命令中给定的IP地址和端口号，向节点B发送一条 MEET消息（message）。 </p>
</li>
<li><p>如果一切顺利，节点B将接收到节点A发送的MEET消息，节点B会为节点A创建一个clusterNode结构，并将该结构添加到自己的clusterState.nodes字典里面。 </p>
</li>
<li><p>之后，节点B将向节点A返回一条PONG消息。</p>
</li>
<li><p>如果一切顺利，节点A将接收到节点B返回的PONG消息，通过这条PONG消息节点A可以知道节点B已经成功地接收到了自己发送的MEET消息。 </p>
</li>
<li><p>之后，节点A将向节点B返回一条PING消息。 </p>
</li>
<li><p>如果一切顺利，节点B将接收到节点A返回的PING消息，通过这条PING消息节点B可以知道节点A已经成功地接收到了自己返回的PONG消息，握手完成。</p>
</li>
<li><p>节点A会将节点B的信息通过Gossip协议传播给集群中的其他节点，让其他节点认识B【raft、pa’xos】</p>
<span id="more"></span></li>
</ul>
</li>
<li><p>数据结构</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">clusterNode</span> &#123; </span><br><span class="line">    <span class="comment">// 创建节点的时间 mstime_t ctime; </span></span><br><span class="line">    <span class="comment">// 节点的名字，由40 个十六进制字符组成 </span></span><br><span class="line">    <span class="comment">// 例如68eef66df23420a5862208ef5b1a7005b806f2ff </span></span><br><span class="line">    <span class="type">char</span> name[REDIS_CLUSTER_NAMELEN]; </span><br><span class="line">    <span class="comment">// 节点标识 </span></span><br><span class="line">    <span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点）， </span></span><br><span class="line">    <span class="comment">// 以及节点目前所处的状态（比如在线或者下线）。</span></span><br><span class="line">    <span class="type">int</span> flags; </span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转移 </span></span><br><span class="line">    <span class="type">uint64_t</span> configEpoch; </span><br><span class="line">    <span class="comment">// 节点的IP 地址char ip[REDIS_IP_STR_LEN]; </span></span><br><span class="line">    <span class="comment">// 节点的端口号 int port; </span></span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息 </span></span><br><span class="line">    clusterLink *link; <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//clusterNode结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信 息，比如套接字描述符，输入缓冲区和输出缓冲区：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">clusterLink</span> &#123; </span><br><span class="line">    <span class="comment">// 连接的创建时间 </span></span><br><span class="line">    <span class="type">mstime_t</span> ctime; </span><br><span class="line">    <span class="comment">// TCP 套接字描述符 </span></span><br><span class="line">    <span class="type">int</span> fd; <span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息（message ）。</span></span><br><span class="line">    sds sndbuf; </span><br><span class="line">    <span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">    sds rcvbuf; </span><br><span class="line">    <span class="comment">// 与这个连接相关联的节点，如果没有的话就为NULL </span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">clusterNode</span> *node; </span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="槽"><a href="#槽" class="headerlink" title="槽"></a><strong>槽</strong></h6><ul>
<li><p>槽数：16384（2048<em>8或者2k</em>8)</p>
</li>
<li><p>状态：如果16384个槽都有节点处理，那就是处于上线状态(ok);否则 下线（failed)</p>
</li>
<li><p>分配方式：CLUSTER ADDSLOTS</p>
</li>
<li><pre><code>struct clusterNode &#123;
// ... 
unsigned char slots[16384/8];
int numslots;
//...
&#125;;
</code></pre>
</li>
<li><p>每个节点都保存了所有的槽信息，只要数据到了任何一个节点，都能一次得到这个数据保存在哪个槽上</p>
</li>
<li><p>在执行命令时，如果key对应的value不在当前节点，则返回moved语义；</p>
</li>
</ul>
<h6 id="重新分片：Redis的集群管理软件redis-trib负责执行"><a href="#重新分片：Redis的集群管理软件redis-trib负责执行" class="headerlink" title="重新分片：Redis的集群管理软件redis-trib负责执行"></a><strong>重新分片</strong>：Redis的集群管理软件redis-trib负责执行</h6><h6 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a><strong>故障转移</strong></h6><ul>
<li><p>复制设置从节点：salveof replicate ip port</p>
</li>
<li><p>故障检测：周期性的发送ping命令，如果ping命令没有在规定的时间内回复，则认为这个主节点疑似下线，只有半数以上负责处理槽的主节点认为这个节点疑似下线。</p>
</li>
<li><p>故障转移：   当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤： </p>
<ul>
<li><p>复制下线主节点的所有从节点里面，会有一个从节点被选中。 </p>
</li>
<li><p>被选中的从节点会执行SLAVEOF no one命令，成为新的主节点。 </p>
</li>
<li><p>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。 </p>
</li>
<li><p>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点 负责处理的槽。</p>
</li>
<li><p>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</p>
</li>
</ul>
</li>
<li><p>从节点选举：raft协议</p>
</li>
</ul>
<h6 id="消息：ping、pong、fail"><a href="#消息：ping、pong、fail" class="headerlink" title="消息：ping、pong、fail"></a><strong>消息：ping、pong、fail</strong></h6>]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis--sds结构</title>
    <url>/2022/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/noSql/redis-sds%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>SDS是redis的字符串struct体，所有的数据结构都依赖于SDS，它是可以简单的理解为char数据或者string类型，但是有区别：SDS是一个结构体，</p>
<p>struct SDS {</p>
<p>  int alloc;     &#x2F;&#x2F;标识有最大的空间大小，剩余空间(alloc-len);不包括head                &#x2F;&#x2F;和’\0’</p>
<p>  int len;       &#x2F;&#x2F;标识使用了多少字节的空间，其中不包括’\0’</p>
<p>  unsinged int flag; &#x2F;&#x2F;标识 struct 的大小类型，为了让空间更加紧密</p>
<p>  char buf[];    &#x2F;&#x2F;保存原始字符的数据</p>
<p>};</p>
<span id="more"></span>

<p>SDS是通过长度判断字符的完成性，所以可以保存不可显示的字符串，这个点std::string 类似；而c字符串是通过’\0’判断，所以可能发生截断；</p>
<table>
<thead>
<tr>
<th>len</th>
<th>alloc</th>
<th>flag</th>
<th>r</th>
<th>e</th>
<th>d</th>
<th>i</th>
<th>s</th>
<th>\0填充</th>
<th></th>
<th></th>
<th>\0</th>
<th>\0</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>通过flag更快的找到更合适的字符串结构，提升写入和查找性能，并且能保证内存的最大化利用；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> curlen = <span class="built_in">sdslen</span>(s);</span><br><span class="line"></span><br><span class="line">    s = <span class="built_in">sdsMakeRoomFor</span>(s,len);</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);</span><br><span class="line">    <span class="built_in">sdssetlen</span>(s, curlen+len);</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接将字符串填补在len长度之后，从最后的’\0’开始memcopy,直接覆盖’\0’,然后再重置最后一个’\0’</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis面试总结</title>
    <url>/2022/02/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/noSql/redis%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h6 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h6><p>定义：当一个热点key之前在redis缓存中存在，后来过期了，然后这个热点key直接去mysql或者底层数据存储介质中查找的时候，由于底层的存储介质并不能抗住最外层的处理，可能导致底层的介质奔溃或者不可用。</p>
<p>方案：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降；热点可以不设置过期时间</p>
<h6 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h6><p>定义：当一个key在缓存中不存在，并且在mysql中也不存在时，导致请求持续访问这两个介质；如果有恶意攻击，导致mysql扛不住挂了，</p>
<p>方案：特定次数请求后设置永久不过期,如果是随机值则存在问题；用布隆过滤器，于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>
<span id="more"></span>

<p>布隆过滤器：</p>
<p>选择一个位数组，这个位数组尽可能大，然后有k个哈希函数；</p>
<p>对每一个元素，根据这个k个哈希函数算出索引值，然后将bit位置1；</p>
<p>当有元素来的时候，查这个字节位数组，如果都是1说明存在，只要有0说明不存在。</p>
<h6 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h6><p>定义：表示在某个时间点，大量的key 过期，导致外层请求直接打在底层存储介质上导致底层介质奔溃或者不可用；</p>
<p>方案：设置不同的过期时间，比如在特定时间的基础上加一个随机时间；分两级缓存，设置不同的缓存时间；热点数据永远不过期；高可用；</p>
<h6 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h6><p>定义：提前将热点数据保存在redis缓存中</p>
<p>方案：通过脚本的方式提前加载</p>
<p>缓存降级：</p>
<p>定义：</p>
<p>方案：</p>
<h6 id="redis-分布式锁"><a href="#redis-分布式锁" class="headerlink" title="redis 分布式锁"></a>redis 分布式锁</h6><p>前置:setnx [ SET if Not eXists]（如果不存在会插入成功，返回1；如果存在，插入不成功，返回0）;setex 存在会覆盖；在set 命令中可以通过EX&#x2F;PX来设置过期时间，通过NX和XX来判断是否存在来设置，NX是不存在设置（not exist),XX存在设置</p>
<p>加锁的时候可以把value设置为一个唯一的id[防止乱释放]</p>
<p>SETEX，用法<code>SETEX key seconds value</code></p>
<p>解锁就是通过lua封装get和del</p>
<p>缺陷：</p>
<ul>
<li><p>客户端长时间阻塞导致锁失效</p>
</li>
<li><p>redis服务器始终漂移问题</p>
</li>
<li><p>单点实例安全问题【为了解决Redis单点问题，redis的作者提出了<strong>RedLock</strong>算法】</p>
</li>
<li><p><strong>锁过期释放，业务没执行完</strong>的问题</p>
<ul>
<li>开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</li>
<li>多机实现的分布式锁Redlock+Redisson，搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</li>
<li><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df0a36c7ccd439291a8a869ff4ddad3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></li>
</ul>
</li>
<li><p>过程</p>
<p>1.获取当前时间，以毫秒为单位。</p>
<p>2.按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。</p>
<p>3.客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N&#x2F;2+1，这里是5&#x2F;2+1&#x3D;3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt; 30ms+40ms+50ms+4m0s+50ms）</p>
<p>如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。</p>
<p>如果获取锁失败（没有在至少N&#x2F;2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。</p>
</li>
</ul>
<p>redis结点宕机了怎么办？某个哨兵节点宕机了怎么办？哨兵的数量对新主节点的选取有什么影响吗？【一般可以3个】</p>
<h6 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h6><p>哨兵模式</p>
<p>redis主结点挂了的话，会自动选出一个主（有一套自己的处理流程，稍微有些复杂），并将变化通知给客户端（旧的主结点，会被自动拉起么？）</p>
<p>redis从结点挂了的话，会被自动拉起么？【通知管理员或者应用程序】</p>
<p>某个哨兵结点宕机了，会被自动拉起么？</p>
<p>哨兵的数量对新主节点的选取有什么影响吗？哨兵的leader选举是用的raft协议，需要超过半数人同意才能选举出来leader，所以至少3个结点（最多容忍1个哨兵宕机）</p>
<p>集群模式</p>
<p>主结点挂了之后，集群会检测到并自动故障恢复（也有一套自己的处理流程，稍微有些复杂）自动选出一个新主（旧主会被自动拉起么？）</p>
<p>从结点挂了之后，会被自动拉起么？</p>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11附录</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/c++/c++11%E9%99%84%E5%BD%95/</url>
    <content><![CDATA[<p>从c++primer截图c++11标准</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/c%2B%2B11-1.JPG"></p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/c%2B%2B11-2.JPG"></p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/c%2B%2B11-3.JPG"></p>
]]></content>
      <categories>
        <category>语言</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++11高级知识点学习1</title>
    <url>/2022/02/21/%E5%9F%BA%E7%A1%80/c++/c++11%E9%AB%98%E7%BA%A7%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="thread-local"><a href="#thread-local" class="headerlink" title="thread_local"></a>thread_local</h3><table>
<thead>
<tr>
<th>static</th>
<th>static变量只初始化一次，除此之外它还有可见性的属性： \1. static修饰函数内的“局部”变量时，表明它不需要在进入或离开函数时创建或销毁。且仅在函数内可见。 \2. static修饰全局变量时，表明该变量仅在当前(声明它的)文件内可见。 \3. static修饰类的成员变量时，则该变量被该类的所有实例共享。</th>
</tr>
</thead>
<tbody><tr>
<td>external</td>
<td>引用一个全局变量。当在一个文件中定义了一个全局变量时，就可以在其它文件中使用extern来声明并引用该变量。</td>
</tr>
<tr>
<td>register</td>
<td>寄存器变量。该变量存储在CPU寄存器中，而不是RAM(栈或堆)中。该变量的最大尺寸等于寄存器的大小。由于是存储于寄存器中，因此不能对该变量进行取地址操作</td>
</tr>
<tr>
<td>mutable</td>
<td>仅适用于类成员变量。以mutable修饰的成员变量可以在const成员函数中修改。</td>
</tr>
<tr>
<td>Thread_local</td>
<td>变量在线程创建时生成;线程结束时被销毁;每个线程都拥有其自己的变量副本;thread_local可以和static或extern联合使用，这将会影响变量的链接属性;需要注意的一点是，如果类的成员函数内定义了 thread_local 变量，则对于同一个线程内的该类的多个对象都会共享一个变量实例，并且只会在第一次执行这个成员函数时初始化这个变量实例，这一点是跟类的静态成员变量类似的；<strong>thread_local 作为类成员变量时必须是 static 的</strong>。</td>
</tr>
</tbody></table>
<h3 id="std-ref"><a href="#std-ref" class="headerlink" title="std::ref()"></a>std::ref()</h3><h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>std::unique_lock 和std::lock_guard都是通过raii实现自动加锁和释放锁，lock_guard速度相对unique快点，而unique相对灵活和慢点。std::unique_lock无参数的构造函数是没有加锁的，不拥有互斥量的锁权利。</p>
<h3 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h3><p>仿函数，其实就是重载了括号运算符 () 的对象, 不过它具有函数的一些性质, 可以在需要函数的地方（主要是<strong>各种</strong><a href="https://cloud.tencent.com/product/tke?from=20065&from_column=20065"><strong>容器</strong></a><strong>和算法</strong>）使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仿函数(functor)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Functor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>仿函数可以不带痕迹地传递上下文参数。而回调技术通常使用一个额外的void*参数传递。这也是多数人认为回调技术丑陋的原因。</li>
<li>更好的性能。</li>
</ul>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>类模版std::function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。</p>
<p>功能：</p>
<ul>
<li>可以实现c的函数指针的功能，作为回调函数</li>
<li>可以作为函数参数进行传递</li>
<li>可以将仿函数赋值给function，然后调用function。</li>
</ul>
<p>关于可调用实体转换为std::function对象需要遵守以下两条原则：</p>
<ul>
<li>转换后的std::function对象的参数能转换为可调用实体的参数；<br>可调用</li>
<li>实体的返回值能转换为std::function对象的返回值。<br>std::function对象最大的用处就是在实现函数回调（实际工作中就是用到了这一点），使用者需要注意，它不能被用来检查相等或者不相等，但是可以与NULL或者nullptr进行比较。</li>
</ul>
<p>可以实现移动和拷贝</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(FUNCTION_TEST, POSITIVE) &#123;</span><br><span class="line">    Callback = Factorial;</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="number">1</span>, <span class="built_in">Callback</span>(<span class="number">-1</span>));</span><br><span class="line">    Callback = func_lambda;</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="number">10</span>, <span class="built_in">Callback</span>(<span class="number">0</span>));</span><br><span class="line">    CompareObject obj;</span><br><span class="line">    Callback = obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">obj</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="number">10</span>, <span class="built_in">Callback</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    Base a1;</span><br><span class="line">    Callback = std::<span class="built_in">bind</span>(&amp;Base::add, a1, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(<span class="number">4</span>, <span class="built_in">Callback</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h3><p>std::future提供了一种访问异步操作结果的机制。从字面意思来理解，它表示未来，我觉得这个名字非常贴切，因为一个异步操作我们是不可能马上就获取操作结果的，只能在未来某个时候获取，但是我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态：</p>
<ul>
<li><p>deferred：异步操作还没开始</p>
</li>
<li><p>ready：异步操作已经完成</p>
</li>
<li><p>timeout：异步操作超时<br>获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果（调用线程阻塞式的），wait只是等待异步操作完成，没有返回值，wait_for是超时等待返回结果。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询future的状态</span></span><br><span class="line">std::future_status status;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = future.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (status == std::future_status::deferred) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;deferred\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == std::future_status::timeout) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;timeout\n&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == std::future_status::ready) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;ready!\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (status != std::future_status::ready);</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h3><p>promise 含义是承诺，承诺给别人反馈一个结果。与future一起使用。std::promise 通过get_future赋值给一个future，然后就可以get这个future了</p>
<p><future> 头文件中包含了以下几个类和函数</p>
<ul>
<li>Providers 类：std::promise, std::package_task</li>
<li>Futures 类：std::future, shared_future.</li>
<li>Providers 函数：std::async()</li>
<li>其他类型：std::future_error, std::future_errc, std::future_status, std::launch.</li>
</ul>
<h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>packaged_task是对任务的抽象，可以将这个任务传递给一个函数来完成，然后通过get_future的方法来获取期望的结果。</p>
<h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h3><p>async异步的完成一个操作，简单的创建线程，然后通过std::future来获取结果</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//(C++11 起) (C++17 前)</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( Function&amp;&amp; f, Args&amp;&amp;... args );</span><br><span class="line"></span><br><span class="line"><span class="comment">//(C++11 起) (C++17 前)</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> <span class="title class_">Function</span>, <span class="keyword">class</span>... Args &gt;</span><br><span class="line">std::future&lt;std::<span class="type">result_of_t</span>&lt;std::<span class="built_in">decay_t</span>&lt;Function&gt;(std::<span class="type">decay_t</span>&lt;Args&gt;...)&gt;&gt;</span><br><span class="line">    <span class="built_in">async</span>( std::launch policy, Function&amp;&amp; f, Args&amp;&amp;... args );  </span><br></pre></td></tr></table></figure>

<p>需要记住的3点：</p>
<ul>
<li>std::async的默认发射策略既允许任务异步执行，又允许任务同步执行。</li>
<li>这个灵活性（上一点）导致了使用thread_local变量时的不确定性，它隐含着任务可能不会执行，它还影响了基于超时的wait调用的程序逻辑。</li>
<li>如果异步执行是必需的，指定std::launch::async发射策略</li>
</ul>
<h3 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h3><h3 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a>std::optional</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>std::optional</code>是C++17中的一个类模板，用于表示可选对象。它是一个容器，可以包含或不包含值，类似于”可空类型”</p>
<p>以下是<code>std::optional</code>的一些关键特性：</p>
<ul>
<li><p>它可以与任何类型一起使用，包括用户定义的类型。</p>
</li>
<li><p>它具有一个值构造函数，用于使用值初始化可选对象。</p>
</li>
<li><p>它具有默认构造函数，用于创建一个空的可选对象。</p>
</li>
<li><p>它有方法来检查它是否包含值（<code>has_value()</code>），访问包含的值（<code>value()</code>），或者在它为空时访问默认值（<code>value_or()</code>）。</p>
</li>
<li><p>它支持移动语义，因此可以有效地传递和从函数返回</p>
</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>那么在使用optional做参数、返回值传递时，optional包裹着的对象是否会进行拷贝、移动等增大程序开销的操作呢？如果会，该如何避免？</p>
<ul>
<li>若以引用类型实例化<code>optional</code>则程序非良构。std::optional&lt;const string&amp;&gt;写法不合理</li>
<li>如果const std::optional<string>&amp; x，具体的string对象还是会进行copy</li>
<li>std::reference_wrapper可以实现类似引用的封装，【就等价于const T<em>，T</em>占用的内存还要比std::optional&lt;std::reference_wrapper<T>&gt;小】</li>
<li>真要说有什么使用上的优势，那么应该就是相比T<em>表义更为清晰、以及在传参时不需要加取地址符&amp;了吧，或许这对部分人来说很重要，但为了方便一般还是推荐使用T</em>，只在传递足够小的对象比如int时，使用std::optional</li>
</ul>
<h3 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h3><h3 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h3><h3 id="std-holds-alternative"><a href="#std-holds-alternative" class="headerlink" title="std::holds_alternative"></a>std::holds_alternative</h3><h3 id="clear和swap测试"><a href="#clear和swap测试" class="headerlink" title="clear和swap测试"></a>clear和swap测试</h3><h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><h3 id="tuple使用"><a href="#tuple使用" class="headerlink" title="tuple使用"></a>tuple使用</h3><h3 id="builtin-expect"><a href="#builtin-expect" class="headerlink" title="__builtin_expect"></a>__builtin_expect</h3><h3 id="std-apply"><a href="#std-apply" class="headerlink" title="std::apply()"></a>std::apply()</h3><h3 id="std-is-base-of"><a href="#std-is-base-of" class="headerlink" title="std::is_base_of"></a>std::is_base_of</h3><h3 id="shared-from-this"><a href="#shared-from-this" class="headerlink" title="shared_from_this"></a>shared_from_this</h3><h3 id="conditional-t"><a href="#conditional-t" class="headerlink" title="conditional_t"></a>conditional_t</h3><ul>
<li><p>当我们新加一个类C的时候，有时候需要继承A,有时候需要继承B,我们怎么做呢？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//使用模板就能解决上面的问题</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> T &#123;&#125;;</span><br><span class="line">C&lt;A&gt; ca;</span><br><span class="line">c&lt;B&gt; cb;</span><br></pre></td></tr></table></figure>


</li>
<li><p>到付件康复科</p>
</li>
<li><p>今飞凯达讲课费</p>
</li>
</ul>
<h3 id="回调为啥不能捕获this"><a href="#回调为啥不能捕获this" class="headerlink" title="回调为啥不能捕获this"></a>回调为啥不能捕获this</h3>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>c++智能指针</title>
    <url>/2022/02/22/%E5%9F%BA%E7%A1%80/c++/c++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>enbale_shared_from_this是一个模板类，std::enable_shared_from_this 能让其一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, … ） ，它们与 pt 共享对象 t 的所有权。为什么要用 <code>enable_shared_from_this</code>？</p>
<p>什么时候使用enable_shared_from_this</p>
<ul>
<li>需要在类对象的内部中获得一个指向当前对象的 shared_ptr 对象。</li>
<li>如果在一个程序中，对象内存的生命周期全部由智能指针来管理。在这种情况下，要在一个类的成员函数中，对外部返回this指针就成了一个很棘手的问题。</li>
</ul>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedPointer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Implement</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Implement</span>(T* p) : <span class="built_in">mPointer</span>(p), <span class="built_in">mRefs</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">        ~<span class="built_in">Implement</span>()&#123; <span class="keyword">delete</span> mPointer;&#125;</span><br><span class="line"></span><br><span class="line">        T* mPointer;  <span class="comment">//实际指针</span></span><br><span class="line">        <span class="type">size_t</span> mRefs;  <span class="comment">// 引用计数</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Implement* mImplPtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SharedPointer</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function">      : mImplPtr(new Implement(p))&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SharedPointer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">decrease</span>();  <span class="comment">// 计数递减</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SharedPointer</span>(<span class="type">const</span> SharedPointer&amp; other)</span><br><span class="line">      : <span class="built_in">mImplPtr</span>(other.mImplPtr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">increase</span>();  <span class="comment">// 计数递增</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SharedPointer&amp; <span class="keyword">operator</span> = (<span class="type">const</span> SharedPointer&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mImplPtr != other.mImplPtr)  <span class="comment">// 避免自赋值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">decrease</span>();</span><br><span class="line">            mImplPtr = other.mImplPtr;</span><br><span class="line">            <span class="built_in">increase</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span> -&gt; () <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mImplPtr-&gt;mPointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span> * () <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *(mImplPtr-&gt;mPointer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decrease</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(--(mImplPtr-&gt;mRefs) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> mImplPtr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++(mImplPtr-&gt;mRefs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>c++知识点--lambda</title>
    <url>/2022/02/19/%E5%9F%BA%E7%A1%80/c++/c++%E7%9F%A5%E8%AF%86%E7%82%B9--lambda/</url>
    <content><![CDATA[<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><h6 id="capture-list-para-list-mutable-exception-gt-returntype-function-body"><a href="#capture-list-para-list-mutable-exception-gt-returntype-function-body" class="headerlink" title="[capture list] (para list) mutable exception -&gt; returntype {function body}"></a>[capture list] (para list) mutable exception -&gt; returntype {function body}</h6><ul>
<li><p>如果是值传递，body不能对值做改变；如果你想对其做改变；可以加上mutable；</p>
</li>
<li><p>返回类型可以自动推导，不用带auto</p>
</li>
<li><p>如果你想有返回类型，必须有参数列表；返回类型必须跟在参数列表的后面，并且必须在返回类型前面包含尾随返回类型关键字字-&gt;</p>
</li>
<li><p>捕获的变量是lambda定义之前的所有局部变量（包括lambda所在的类内），局部静态变量可以直接使用</p>
<span id="more"></span>
<h6 id="编译器实现原理"><a href="#编译器实现原理" class="headerlink" title="编译器实现原理"></a>编译器实现原理</h6></li>
<li><p>编译器创建一个lambda类,实现构造函数；重载函数调用运算符（其实就是扩号）</p>
</li>
<li><p>创建lambda对象</p>
</li>
<li><p>通过这个对象调用operator()</p>
</li>
<li><p>代码实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class lambda_xxxx</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int c;</span><br><span class="line">    int b;</span><br><span class="line">public:</span><br><span class="line">    lambda_xxxx(int _a, int _b) :c(_a), b(_b)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    bool operator()(int x, int y) throw()</span><br><span class="line">    &#123;</span><br><span class="line">        return c + b &gt; x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void LambdaDemo()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 1;</span><br><span class="line">    int b = 2;</span><br><span class="line">    lambda_xxxx lambda = lambda_xxxx(a, b);</span><br><span class="line">    bool ret = lambda.operator()(3, 4);</span><br><span class="line">&#125;</span><br><span class="line">//其中，类名 lambda_xxxx 的 xxxx 是为了防止命名冲突加上的</span><br></pre></td></tr></table></figure>
</li>
<li><p>lambda_xxxx 与 lambda 表达式 的对应关系</p>
<ul>
<li>lambda 表达式中的<strong>捕获列表</strong>，对应 lambda_xxxx 类的 <strong>private 成员</strong></li>
<li>lambda 表达式中的<strong>形参列表</strong>，对应 lambda_xxxx 类成员函数 <strong>operator() 的形参列表</strong></li>
<li>lambda 表达式中的 <strong>mutable</strong>，对应 lambda_xxxx 类成员函数 <strong>operator() 的常属性 const</strong>，即是否是 <strong>常成员函数</strong></li>
<li>lambda 表达式中的<strong>返回类型</strong>，对应 lambda_xxxx 类成员函数 <strong>operator() 的返回类型</strong></li>
<li>lambda 表达式中的<strong>函数体</strong>，对应 lambda_xxxx 类成员函数 <strong>operator() 的函数体</strong></li>
<li>另外，lambda 表达 捕获列表的捕获方式，也影响 对应 lambda_xxxx 类的 private 成员 的类型</li>
<li>值捕获：private 成员 的类型与捕获变量的类型一致</li>
<li>引用捕获：private 成员 的类型是捕获变量的引用类型</li>
</ul>
</li>
</ul>
<!-- more -->

<h3 id="右值相关"><a href="#右值相关" class="headerlink" title="右值相关"></a>右值相关</h3><ul>
<li><p>右值要么是常量，要么是临时表达式</p>
</li>
<li><p>右值表示放在等号右边，不能放在等号左边的量，一般都是常量，右值不具有名称（匿名变量）；【左值和右值的区分办法，能不能对这个表达式取地址】</p>
</li>
<li><p>右值引用就是绑定到右值或者临时对象上，如：int&amp;&amp; A &#x3D; 0; int &amp;&amp; a &#x3D;geta();</p>
</li>
<li><p>c++11之前更偏向于右值是一种常量引用。右值引用相当于把他两细化开了。</p>
</li>
<li><p>引用折叠：</p>
<ul>
<li><p>所有的右值引用叠加到右值引用上仍然还是一个右值引用；</p>
</li>
<li><p>所有的其他引用类型之间的叠加都将变成左值引用</p>
</li>
<li><p>引用不是对象，所以没有引用的引用，因此间接定义时，一旦出现引用的引用，就要进行折叠</p>
</li>
<li><p>X&amp; &amp;, X&amp; &amp;&amp;, X&amp;&amp; &amp;都折叠成X&amp;</p>
</li>
<li><p>X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</p>
</li>
</ul>
</li>
<li><p>右值引用解决了对象深拷贝的问题，因为传右值引用调用移动赋值用算符和移动构造函数。</p>
</li>
<li><pre><code class="c++">#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
using namespace std;
class RightValueTest &#123;
private:
    std::string str;
public:
    RightValueTest(const string&amp; s) : str(s) &#123;
        std::cout &lt;&lt;&quot;RightValueTest con&quot; &lt;&lt; std::endl;
    &#125;
    RightValueTest(const RightValueTest&amp; obj) &#123;
        std::cout &lt;&lt;&quot;RightValueTest copy&quot; &lt;&lt; std::endl;
        str = obj.str;
    &#125;
    RightValueTest(RightValueTest&amp;&amp; obj) &#123;
        std::cout &lt;&lt;&quot;RightValueTest move&quot;;
        str = std::move(obj.str);
        std::cout &lt;&lt;&quot; ,after origin obj.str:&quot; &lt;&lt; obj.str &lt;&lt; &quot;--&quot; &lt;&lt; std::endl;
    &#125;
    RightValueTest&amp; operator= (const RightValueTest&amp; obj) &#123;
        std::cout &lt;&lt;&quot;left value = &quot; &lt;&lt; std::endl;
        str = obj.str;
        return *this;
    &#125;
    RightValueTest&amp; operator= (RightValueTest&amp;&amp; obj) &#123;
        std::cout&lt;&lt;&quot;right value = &quot;;
        str = std::move(obj.str);
        std::cout&lt;&lt;&quot; ,after origin obj.str:&quot; &lt;&lt; obj.str &lt;&lt; std::endl;
        return *this;
    &#125;
    void print() &#123;
        std::cout &lt;&lt; &quot;print str value:&quot; &lt;&lt; str &lt;&lt; endl;
    &#125;
    ~RightValueTest() &#123;
        std::cout &lt;&lt; &quot;xigou RightValueTest&quot; &lt;&lt; std::endl;
    &#125;
&#125;;
int func(std::vector&lt;RightValueTest&gt;&amp; vect) &#123;
    std::vector&lt;RightValueTest&gt; tmp_vect;
    tmp_vect.reserve(5);
    RightValueTest test6(&quot;1314&quot;);
    tmp_vect.push_back(test6);
    tmp_vect.push_back(test6);
    tmp_vect.push_back(test6);
    tmp_vect.push_back(test6);
    tmp_vect.push_back(test6);
    for(auto&amp; ele : tmp_vect) &#123;
        vect.emplace_back(std::move(ele));
    &#125;

&#125;
int main() &#123;
    std::vector&lt;RightValueTest&gt; vect;
    //RightValueTest test1(std::move(&quot;abc&quot;));
   /* RightValueTest test1(&quot;abc&quot;);
    RightValueTest test2 = std::move(test1);
    test2.print();
    test1.print();

    RightValueTest test3(&quot;xxx&quot;);
    RightValueTest test4(&quot;ooo&quot;);
    test4 = std::move(test3);
    test3.print();
    test4.print();
    vect.reserve(5);
    cout &lt;&lt; &quot;size: &quot; &lt;&lt; vect.size() &lt;&lt; &quot;, capacity: &quot; &lt;&lt; vect.capacity() &lt;&lt; endl;
    vect.emplace_back(std::move(test4));*/
    RightValueTest test5(&quot;520&quot;);
    test5.print();
    vect.push_back(test5);
    cout &lt;&lt; &quot;size: &quot; &lt;&lt; vect.size() &lt;&lt; &quot;, capacity: &quot; &lt;&lt; vect.capacity() &lt;&lt; endl;
    //func(vect);

    //cout &lt;&lt; &quot;size: &quot; &lt;&lt; vect.size() &lt;&lt; &quot;, capacity: &quot; &lt;&lt; vect.capacity() &lt;&lt; endl;
    //for(auto&amp; ele : vect) &#123;
//	    ele.print();
  //  &#125;
    //vect.emplace_back(test4);
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">- std::move()是将一个变量强制转化为一个右值</span><br><span class="line"></span><br><span class="line">  ```c++</span><br><span class="line">  //在返回类型和类型转换中也要用到typename</span><br><span class="line">  template &lt;typename T&gt;</span><br><span class="line">  typename remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; t)</span><br><span class="line">  &#123;</span><br><span class="line">      return static_cast&lt;typename remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>完美转义：通过std::forward()进行完美转义</p>
</li>
<li><p>右值的特点：</p>
<ul>
<li>右值引用使右值和其变量生命周期一样长；</li>
<li>只有在泛型编程中，右值引用的参数才是通用的应用类型，他有时候是左值引用；有时候是右值引用，具体看传入的参数。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>c++知识点--关键字</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/c++/c++%E7%9F%A5%E8%AF%86%E7%82%B9--stastic/</url>
    <content><![CDATA[<h6 id="静态关键字（static）"><a href="#静态关键字（static）" class="headerlink" title="静态关键字（static）"></a>静态关键字（static）</h6><ul>
<li><p>静态成员（类）函数和变量都是类共有；在初始化的时候分配全局区的静态区空间；sizeof 类对象的时候排除静态成员变量大小；静态成员函数只能调用静态的成员函数或者变量；静态成员变量在程序结束的时候释放空间</p>
</li>
<li><p>静态全局变量从定义开始只在本文件中可见，其他文件中不能使用，即使定义为extern的也不行</p>
</li>
<li><p>静态局部变量在全局数据区分配内存；静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；</p>
<span id="more"></span>
<h6 id="引用和指针"><a href="#引用和指针" class="headerlink" title="引用和指针"></a>引用和指针</h6></li>
<li><p>引用是个别名，指针是类型；指针有空间大小，引用没有；指针不需要强制初始化，引用必须初始化；指针有多级，引用只有一级并且不用</p>
</li>
</ul>
<h6 id="std-function和std-bind的"><a href="#std-function和std-bind的" class="headerlink" title="std :: function和std :: bind的"></a>std :: function和std :: bind的</h6><ul>
<li><p>用途是安全函数指针。std::bind是用于把已知函数和某个形式的参数列表进行绑定，形成新的函数（函数调用对象）来适应原函数（调用对象）的参数列表；可以理解为一个通用函数适配器；</p>
</li>
<li><p>形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_callback = std::<span class="built_in">bind</span>(func,  args_list);</span><br><span class="line"><span class="comment">//调用new_callback的时候会调用func，把args_list中的参数传递给func，其中args_list中可能包含形如_n的名字，其中n是整数，表示新生成的可调用对象中参数的位置，_1表示一个参数，_2第二个；</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>样例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vect, <span class="type">int</span> start, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; vect.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vect[i] &gt;= num) &#123;</span><br><span class="line">            std::cout &lt;&lt; vect[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vect&#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> new_callback = std::<span class="built_in">bind</span>(func, _1, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">new_callback</span>(vect);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以改变参数个数和顺序；也可以绑定引用，通过ref标准库函数；</p>
<p>std::function实现函数的回调；</p>
</li>
</ul>
<h6 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h6><ul>
<li>表示对小函数在编译的时候展开，不进行压栈（改变esp指针）；减少函数调用次数，节省开支；容易代码膨胀；</li>
</ul>
<h6 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h6><ul>
<li>缓存方式<ul>
<li>栈：一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放。</li>
<li>堆：二级缓存，<a href="https://so.csdn.net/so/search?q=%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1001.2101.3001.7020">生命周期</a>由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。堆可以被看成一颗树，如堆排序</li>
</ul>
</li>
</ul>
<h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><ul>
<li>哪些函数不能是虚函数：构造函数、静态函数、模板函数（编译时生成代码）、友元函数（编译时替换）</li>
<li>raii【resource acquire is init ]通过在资源获取时通过对象来初始化资源，然后使用资源（对象），在对象声明周期结束的时候释放资源；【构造函数—析构函数】</li>
<li>RTTI【running time type identify】</li>
<li><ul>
<li>通过typeid能返回类型或者变量的具体类型</li>
<li>通过dynamic_cast 进行类对象的类型转换，一般是向下转，存在转失败，返回nullptr的情况。</li>
</ul>
</li>
<li>auto:模板类型推到</li>
<li>mutable声明变量是可变的，是能是非静态和非常量的变量里用，但是可以再常量成员函数中可以改变值；</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>样例模板</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/c++/c++%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li><p>库编译问题，glog依赖gflags需要编译成动态库</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/image-20230302102258655.png"></p>
</li>
<li><p>protobuf的三个动态库都要链接，并且要先加dependence的pb依赖</p>
<p>![image-20230302113818125](&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230302113818125.png)</p>
</li>
<li><p>在开启单元测试的时候，glog和gflags 都依赖gtest，不然会有链接问题</p>
</li>
<li><p>cmake错误</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/image-20230306175300742.png" alt="image-20230306175300742"></p>
<p>在文件flags.make:8；在第8行有格式错误导致报错；</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/image-20230419183158371.png" alt="image-20230419183158371"></p>
<p>由于没有链接cpp文件导致找不到定义，cmake 写的有问题</p>
</li>
<li><p>fdafsa</p>
</li>
</ol>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>c++知识点--模板</title>
    <url>/2022/02/21/%E5%9F%BA%E7%A1%80/c++/c-%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><hr>
<h6 id="类在堆上构建"><a href="#类在堆上构建" class="headerlink" title="类在堆上构建"></a>类在堆上构建</h6><ul>
<li>按照单例或者把析构函数设置为私有的</li>
</ul>
<h6 id="类在栈上构建"><a href="#类在栈上构建" class="headerlink" title="类在栈上构建"></a>类在栈上构建</h6><p>只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可</p>
<h3 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h3><hr>
<ul>
<li><p>模板类：模板定义只是声明一个蓝图或者公式；只有在实例化的时候才会生成真正的代码（也就是调用的接口处）</p>
<ul>
<li><p>特化：就是按照特定类型去实现一个类模板。</p>
</li>
<li><p>偏特化：模板偏特化（Template Partitial Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性分而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有的模板参数进行特化。模板全特化与模板偏特化共同组成模板特化。模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。</p>
</li>
<li><p>typename在下面情况下禁止使用：</p>
<ul>
<li>模板定义之外，即typename只能用于模板的定义中</li>
<li>非限定类型，比如前面介绍过的<code>int</code>，<code>vector&lt;int&gt;</code>之类</li>
<li>基类列表中，比如<code>template &lt;class T&gt; class C1 : T::InnerType</code>不能在<code>T::InnerType</code>前面加typename</li>
<li>构造函数的初始化列表中<span id="more"></span></li>
</ul>
</li>
<li><p>类可以包含本身是模板的成员函数。这种成员称为成员模板。成员模板不能是虚函数</p>
</li>
<li><p>因为模板只有使用时才会实例化，所以相同的实例如果出现在不同的对象文件中，多个源文件使用了相同的模板，并提供了相同的模板参数时，就会导致每个文件中都有该模板的一个实例。这会引起代码体积膨胀，C++11以后允许通过显式实例化来避免这种开销</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;;  <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;  <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些情况下编译器无法推导出模板实参的类型，这时我们可以显式地控制模板实例化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br><span class="line"><span class="comment">//无法推断出T1的类型，因为T1不在函数参数中出现//T1是显式指定的，T2和T3是从函数实参类型推断出来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = <span class="built_in">sum</span>&lt;<span class="type">long</span> <span class="type">long</span>&gt;(i, lng);  <span class="comment">//long long sum(int ,long)</span></span><br><span class="line"><span class="comment">//显式指定模板实参要严格按照自左向右的顺序来匹配，可以指定全部，也可以指定部分。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>尾置返回类型与类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理</span></span><br><span class="line">    <span class="keyword">return</span> *beg;  <span class="comment">//返回序列第一个元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fi=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;string&gt; ca=&#123;<span class="string">&quot;hi&quot;</span>,<span class="string">&quot;bye&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = <span class="built_in">fcn</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>());<span class="comment">//fcn返回int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = <span class="built_in">fcn</span>(ca.<span class="built_in">begin</span>(), ca.<span class="built_in">end</span>());<span class="comment">//fcn返回string&amp;</span></span><br><span class="line"><span class="comment">//decltype作用于表达式时，如果表达式返回的是左值，则decltype返回左值引用。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt; <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//处理</span></span><br><span class="line">  <span class="keyword">return</span> *beg;  <span class="comment">//返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//remove_reference获得元素类型。它有一个模板类型参数和一个名为type的类型成员。如果用引用类型实例化remove_reference，则type就表示被引用的类型。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数指针和实参推导利用std::forward() 可以兼容形参类型透传</p>
</li>
<li><p>函数模板可以被模板函数或者普通函数重载</p>
<ul>
<li>函数匹配规则</li>
</ul>
</li>
<li><p>可变参数模板</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t;  <span class="comment">//包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;...reset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;<span class="comment">//打印第一个实参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, reset...);  <span class="comment">//递归调用，打印其他参数</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>包扩展就是加上3个点</li>
</ul>
</li>
<li><p>模板特例化</p>
<ul>
<li>模板函数不提供偏特化版本，通过重载实现</li>
<li>可以偏特化、特化和普通的都实现</li>
</ul>
</li>
<li><p>模板类限制类型：c++11提供enable_if和is_base_of（判断一个是否是另一个的基类）</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>stl相关</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/c++/stl%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<span id="more"></span>

<h6 id="stl常用算法"><a href="#stl常用算法" class="headerlink" title="stl常用算法"></a>stl常用算法</h6><ul>
<li>生成全排列</li>
<li>排序(sort、)</li>
<li>统计(count、cout_if)</li>
<li>去重（unique）</li>
<li>查找（find、find_if)</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>go初始了解</title>
    <url>/2022/10/13/%E5%9F%BA%E7%A1%80/go/go-mod%E5%88%9D%E8%AF%86/</url>
    <content><![CDATA[<h5 id="go-module"><a href="#go-module" class="headerlink" title="go module"></a>go module</h5><h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p>若是想要在其他位置新建go项目，就不得不更改系统变量GOPATH，将其设为新项目的位置，可能还要改goland中的GOPATH设置。</p>
<p>go mod是golang1.11后引入的package依赖管理工具，用于解决之前没有地方记录依赖包具体版本的问题，方便依赖包管理。<br>之前主要是用GOPATH 和 Vendor，vendor相对主流，但现在官方更提倡go mod。</p>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><p>​		go mod init modulename</p>
<h6 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h6><p>GO111MODULE</p>
<p>在 GOPATH 目录之外新建一个目录，并使用<code>go mod init</code>初始化生成 go.mod 文件。go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。将需要引入外部包的go文件置于项目目录下，编译文件，就会把外部包下载到本地的GOPATH&#x2F;pkg&#x2F;mod目录下。<br>set GO111MODULE&#x3D;off，GOPATH mode，查找vendor和GOPATH目录。<br>set GO111MODULE&#x3D;auto，如果当前目录不在$GOPATH 并且 当前目录（或者父目录）下有go.mod文件，则使用 GO111MODULE， 否则仍旧使用 GOPATH mode</p>
<h6 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h6><ul>
<li>项目名字</li>
<li>版本</li>
<li>第三方包</li>
</ul>
<p>go.mod 提供了 module、require、replace 和 exclude 四个命令[第三方包使用方式]：</p>
<ul>
<li><p>require 语句指定的依赖项模块；</p>
</li>
<li><p>replace 语句可以替换依赖项模块；替换无法直接获取的package</p>
<ul>
<li>当项目没上传到git的时候，可以用replace 替换成本地项目</li>
</ul>
</li>
<li><p>exclude 语句可以忽略依赖项模块。</p>
</li>
</ul>
<p>go mod edit -require&#x3D;”<a href="mailto:&#x78;&#120;&#120;&#x78;&#x40;&#118;&#46;&#120;&#x78;&#120;">&#x78;&#120;&#120;&#x78;&#x40;&#118;&#46;&#120;&#x78;&#120;</a>“修改版本</p>
<p>go get使用该命令下载公开库，会把依赖下载到第一个gopath下</p>
<p>go mod vendor</p>
<h6 id="go-sum"><a href="#go-sum" class="headerlink" title="go.sum"></a>go.sum</h6><h5 id="导入import"><a href="#导入import" class="headerlink" title="导入import"></a>导入import</h5><h6 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h6><h6 id="点操作"><a href="#点操作" class="headerlink" title="点操作"></a>点操作</h6><p>这个点操作的含义就是这个包导入之后在你调用这个包的函数时，你可以省略前缀的包名，也就是前面你调用的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> . “fmt”</span><br><span class="line">fmt.Println(“hello world”) </span><br><span class="line"><span class="comment">//可以省略的写成</span></span><br><span class="line">Println(“hello world”)</span><br></pre></td></tr></table></figure>



<h6 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h6><p>别名操作顾名思义可以把包命名成另一个自己绝对方便的名字</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>( f “fmt” )  </span><br><span class="line"><span class="comment">//别名操作调用包函数时前缀变成了重命名的前缀，即</span></span><br><span class="line">f.Println(“hello world”)</span><br></pre></td></tr></table></figure>



<h6 id="操作"><a href="#操作" class="headerlink" title="_ 操作"></a>_ 操作</h6><p><strong>_</strong> 操作其实只是引入该包，只是使用该包的init函数，并不显示的使用该包的其他内容。注意：这种形式的import，当import时就执行了fmt包中的init函数，而不能够使用该包的其他函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h5 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h5><p>go build xxx.go</p>
<h6 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h6><p>go run xxx.go</p>
<h5 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h5><ol>
<li><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/image-20221014171252113-20221014171459118.png"></p>
<p>Go mod init modulename(项目名字)</p>
</li>
<li><p>![image-20221014180545475](&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20221014180545475.png)</p>
<p>配置GO111MODULE&#x3D;auto</p>
</li>
<li><p>go的import的包一定要使用，不然就会被go mod tidy清理、优化掉</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/image-20221014202125815.png">读了sum.goland.org,需要配置，GONOPROXY&#x3D;”gitlab.xxx.com”，GONOSUMDB&#x3D;”gitlab.xxxx.com”，GOPRIVATE&#x3D;”gitlab.xxx.com”</p>
</li>
<li><p>东方饭店</p>
</li>
<li><p>烦啥科技</p>
</li>
</ol>
<h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><p><a href="https://juejin.cn/post/7026523806730551333">https://juejin.cn/post/7026523806730551333</a></p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>go基本语法</title>
    <url>/2023/03/07/%E5%9F%BA%E7%A1%80/go/go%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>[toc]</p>
<h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><p>这是因为在Golang中，<strong>没有强制要求包名和目录名称一致</strong>。也就是说，在上面的例子中，我们引用路径中的文件夹名称是<code>package2</code>，而在这个文件夹下面的两个文件，他们的包名，却被设置成了<code>同一个。而在Golang的引用中，我们需要填写的是**源文件所在的相对路径**。也就是说，我们可以理解为，包名和路径其实是两个概念，文件名在Golang中不会被显式的引用，通常的引用格式是</code>packageName.FunctionName&#96;。</p>
<p>结论如下：</p>
<ul>
<li>导入包的时候，除了路径，还要加上module的名字</li>
<li>import导入的是文件的名字，而不是包名</li>
<li>在习惯上将包名和文件夹名设置为一样，但这不是强制规定（但是不建议这么做，容易不能发现是在哪个文件中）</li>
<li>在用函数或者变量的时候，用的是包名，而不是文件夹的名字</li>
<li></li>
</ul>
<h5 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h5><p>nil<code>是一个</code>Type<code>，根据源码 </code>var nil Type<code>，它其实也是 **Golang** 中的一中类型，nil 的类型必须是一个指针，通道，函数，接口，字典，切片类型,</code>nil<code> 只能赋值给指针、</code>channel<code>、</code>func<code>、</code>interface<code>、</code>map<code>或</code>slice&#96; 类型的变量</p>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><h6 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h6><ul>
<li>var para_name type</li>
<li>var a int</li>
<li>var a bool</li>
<li>var a *int</li>
<li>var a []int</li>
<li>var a map[int] string</li>
<li>var a chan</li>
<li>var a error</li>
</ul>
<p>var a fun(string) int</p>
<p>var a slice</p>
<p>const a int &#x3D; 20</p>
<p>匿名变量：用_ 标识一个占位符，在被赋值后，会立即被操作系统回收，通常在批量赋值的时候使用</p>
<p>对于变量的声明也可以用:&#x3D; 来定义自动推导，在之前声明的变量使用:&#x3D;会报错;:&#x3D;不能用于全局变量的声明</p>
<p>可以用括号声明多个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">		a <span class="type">int</span></span><br><span class="line">  	b <span class="type">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h5 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h5><p>函数名的首字母要大写,对包来说就是public 的函数；函数名的首字母是小写，对包来说是private；</p>
<p>func Func_name(para1, para2) return_type {</p>
<p>​	func_body</p>
<p>} </p>
<p>调用的时候通过报名</p>
<p>返回多个参数的时候用括号括起来</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组大小不能被改变</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">10</span>]<span class="type">int</span> <span class="comment">//必须被使用，size也是常量</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<h6 id="切片（相当于动态数组，c-–vector"><a href="#切片（相当于动态数组，c-–vector" class="headerlink" title="切片（相当于动态数组，c++–vector)"></a>切片（相当于动态数组，c++–vector)</h6><p>含义：是按照需要切成自己想要的部分</p>
<p>由于数组是固定大小的，切片可以提供一个动态的、灵活的动态数组结构；</p>
<p>切片通过一个左闭右开的半开区间来标识；slices[1:3]</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">		arr1[i] = i</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">for</span> ele, _ := <span class="keyword">range</span> arr1 &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;%d&quot;</span>, ele)</span><br><span class="line">&#125;</span><br><span class="line">	slices1 := arr1[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(<span class="string">&quot;\nslices: &quot;</span>, slices1)</span><br><span class="line">	slices2 := arr1[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">	<span class="comment">//slices2[0] = 100 会改变原始的数组，指针的关系</span></span><br><span class="line">	slices2 = <span class="built_in">append</span>(slices2, <span class="number">106</span>, <span class="number">107</span>, <span class="number">108</span>)</span><br><span class="line">	slices2[<span class="number">0</span>] = <span class="number">100</span> <span class="comment">//不会改变，slices2的指针有变化</span></span><br></pre></td></tr></table></figure>

<p>对切片进行赋值的时候，也会改变底层的数据的值；对切片进行append时候，如果当前<em>切片</em>空间不足的时候，会新建一个切片的空间然后将旧空间的元素拷贝过来，这样并不会改变原始数据的值；</p>
<p>通过make函数可以创建切片,相当于创建</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slices1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>) <span class="comment">// len是10个</span></span><br><span class="line">slices2 ：= <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10</span>, <span class="number">20</span>) <span class="comment">// len是10，cap是20</span></span><br></pre></td></tr></table></figure>

<p>数组在定义的时候会指定其大小；切片不用指定大小</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组</span></span><br><span class="line">arr1 := [<span class="number">4</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">//切片</span></span><br><span class="line">slices1 := []<span class="type">int</span>&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// nil切片</span></span><br><span class="line"><span class="keyword">var</span> slices1 []<span class="type">int</span> </span><br></pre></td></tr></table></figure>

<h6 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h6><p>一个数组，数据类型是地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptrs [size]*<span class="type">int</span></span><br><span class="line"><span class="comment">// var ptrArr [size] *Type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptrs [<span class="number">4</span>]*<span class="type">int</span></span><br><span class="line">a, b, c, d := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">ptrs = [<span class="number">4</span>]*<span class="type">int</span> &#123;&amp;a, &amp;b, &amp;c, &amp;d&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h6><p>一个指针，一个地址；数据还是数组，指向数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrptr *[size]<span class="type">int</span></span><br><span class="line"><span class="comment">// *arrPtr[0]</span></span><br><span class="line"><span class="comment">// (*arrPtr)[0]* 寻址运算符和 [] 中括号运算符的优先级是不同的,加括号</span></span><br></pre></td></tr></table></figure>





<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[KeyType]ValueType, initialCapacity)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">AdInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> testMap <span class="keyword">map</span>[<span class="type">string</span>]AdInfo</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化 make</p>
<h5 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h5><p>defer的执行推迟到defer所在函数（外层函数）执行完毕才执行，并且defer后面只能是函数调用，defer用于资源的释放，defer是在return之前执行的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (r <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">          r = r + <span class="number">5</span></span><br><span class="line">    &#125;(r)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><p>go 没有指针运算；&amp;取地址；*获取值</p>
<h5 id="panic-和-recover"><a href="#panic-和-recover" class="headerlink" title="panic 和 recover"></a>panic 和 recover</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="make和new"><a href="#make和new" class="headerlink" title="make和new"></a>make和new</h4><h5 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h5><p>结构体的定义也遵循首字规则；包外访问的struct，定义的时候必须是名字首字母大写，否则小写；如果是struct的成员变量，和struct遵循一样的规则;</p>
<p>在struct中，无论使用的是指针的方式声明还是普通方式，访问其成员都使用”.”，在访问的时候编译器会自动把 stu2.name 转为 (*stu2).name。</p>
<p>struct分配内存使用new，返回的是指针。</p>
<p>struct没有构造函数，但是我们可以自己定义“构造函数”。</p>
<p>struct是我们自己定义的类型，不能和其他类型进行强制转换。</p>
<h6 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h6><p>使用字面量创建变量，这种使用方式，可以在大括号中为结构体的成员赋初始值，有两种赋初始值的方式，一种是按字段在结构体中的顺序赋值，下面代码中<code>m2</code>就是使用这种方式，这种方式要求所有的字段都必须赋值，因此如果字段太多，每个字段都要赋值，会很繁琐，另一种则使用字段名为指定字段赋值，如下面代码中变量<code>m3</code>的创建，使用这种方式，对于其他没有指定的字段，则使用该字段类型的零值作为初始化值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">		id     <span class="type">int</span></span><br><span class="line">    name   <span class="type">string</span></span><br><span class="line">    email  <span class="type">string</span></span><br><span class="line">    gender <span class="type">int</span></span><br><span class="line">    age    <span class="type">int</span></span><br><span class="line">    prices []<span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m2 = Student&#123;<span class="number">1</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;xiaoming@163.com&quot;</span>,<span class="number">1</span>,<span class="number">18</span>&#125; <span class="comment">// 简短变量声明方式：m2 := Member&#123;1,&quot;小明&quot;,&quot;xiaoming@163.com&quot;,1,18&#125;</span></span><br><span class="line"><span class="keyword">var</span> m3 = Student&#123;id:<span class="number">2</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;小红&quot;</span>&#125;<span class="comment">// 简短变量声明方式：m3 := Member&#123;id:2,&quot;name&quot;:&quot;小红&quot;&#125;</span></span><br><span class="line"><span class="keyword">var</span> m4 = Student&#123;id:<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>结构体也可以不包含任何字段，称为<code>空结构体</code>，struct{}表示一个空的结构体，注意，直接定义一个空的结构体并没有意义，但在并发编程中，channel之间的通讯，可以使用一个struct{}作为信号量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="keyword">chan</span>(<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ch &lt;- <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h6 id="指针结构体"><a href="#指针结构体" class="headerlink" title="指针结构体"></a>指针结构体</h6><p>构造函数</p>
<h6 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h6><p>只要是可导出成员（变量首字母大写），都可以用json、pb、xml等tag，并且支持同时多个tag</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserId   <span class="type">int</span>    <span class="string">`json:&quot;user_id&quot; bson:&quot;b_user_id&quot;`</span></span><br><span class="line">    UserName <span class="type">string</span> <span class="string">`json:&quot;user_name&quot; bson:&quot;b_user_name&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在定义结构体字段时，除字段名称和数据类型外，还可以使用反引号为结构体字段声明元信息，这种元信息称为Tag，用于编译阶段关联到字段当中,如我们将上面例子中的结构体修改为</p>
<p>tag可以为结构体的成员添加说明或者标签便于使用,这些说明可以通过反射获取到。</p>
<p>在前面提到了，结构体中的成员首字母小写对外不可见，但是我们把成员定义为首字母大写这样与外界进行数据交互会带来极大的不便，此时tag带来了解决方法。</p>
<h6 id="匿名结构体和匿名字段（字段、属性"><a href="#匿名结构体和匿名字段（字段、属性" class="headerlink" title="匿名结构体和匿名字段（字段、属性)"></a>匿名结构体和匿名字段（字段、属性)</h6><p>匿名字段实现is a的继承方式</p>
<h6 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h6><p>组合实现has a的继承方式</p>
<h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><ol>
<li>值传递<ol>
<li>结构体是复合类型，只能通过复制一个副本来作为函数参数或者作为赋值的对象</li>
</ol>
</li>
<li>不能继承<br>1. </li>
<li>结构体不能包含自己<ol>
<li>不能包含自己的对象，可以包含对象的指针</li>
</ol>
</li>
</ol>
<h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><h6 id="结构体模拟继承性"><a href="#结构体模拟继承性" class="headerlink" title="结构体模拟继承性"></a>结构体模拟继承性</h6><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h5><p>proto.Unmarshal（json, </p>
<h5 id="go-test"><a href="#go-test" class="headerlink" title="go test"></a>go test</h5><h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>文件名必须是以<code>_test</code>结尾的源码；函数必须<code>Test</code>开头的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> xxx</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestHelloWorld</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Log(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h6><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> test helloworld_test.<span class="keyword">go</span></span><br><span class="line"><span class="comment">//指定 TestA函数 进行测试：</span></span><br><span class="line"><span class="keyword">go</span> test -v -run TestA select_test.<span class="keyword">go</span></span><br><span class="line"><span class="comment">//-run跟随的测试用例的名称支持正则表达式，使用-run TestA$即可只执行 TestA 测试用例</span></span><br><span class="line"><span class="keyword">go</span> test -v .</span><br></pre></td></tr></table></figure>

<h6 id="单元测试日志"><a href="#单元测试日志" class="headerlink" title="单元测试日志"></a>单元测试日志</h6><p>每个测试用例可能并发执行，使用 testing.T 提供的日志输出可以保证日志跟随这个测试上下文一起打印输出。testing.T 提供了几种日志输出方法，详见下表所示。</p>
<table>
<thead>
<tr>
<th>方  法</th>
<th>备  注</th>
</tr>
</thead>
<tbody><tr>
<td>Log</td>
<td>打印日志，同时结束测试</td>
</tr>
<tr>
<td>Logf</td>
<td>格式化打印日志，同时结束测试</td>
</tr>
<tr>
<td>Error</td>
<td>打印错误日志，同时结束测试</td>
</tr>
<tr>
<td>Errorf</td>
<td>格式化打印错误日志，同时结束测试</td>
</tr>
<tr>
<td>Fatal</td>
<td>打印致命日志，同时结束测试</td>
</tr>
<tr>
<td>Fatalf</td>
<td>格式化打印致命日志，同时结束测试</td>
</tr>
</tbody></table>
<h5 id="基准测试——获得代码内存占用和运行效率的性能数据"><a href="#基准测试——获得代码内存占用和运行效率的性能数据" class="headerlink" title="基准测试——获得代码内存占用和运行效率的性能数据"></a>基准测试——获得代码内存占用和运行效率的性能数据</h5><p>基准测试可以测试一段程序的运行性能及耗费 CPU 的程度。Go语言中提供了基准测试框架，使用方法类似于单元测试，使用者无须准备高精度的计时器和各种分析工具，基准测试本身即可以打印出非常标准的测试报告。</p>
<span id="more"></span>

]]></content>
  </entry>
  <entry>
    <title>go框架</title>
    <url>/2022/03/08/%E5%9F%BA%E7%A1%80/go/go%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>go进阶</title>
    <url>/2022/05/19/%E5%9F%BA%E7%A1%80/go/go%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><h5 id="上下文和context"><a href="#上下文和context" class="headerlink" title="上下文和context"></a>上下文和context</h5><h5 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h5><h6 id="interface"><a href="#interface" class="headerlink" title="interface{}"></a>interface{}</h6><p>任何其他类型的数据都可以赋值给interface{}类型</p>
<h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>包含一组方法或者函数的集合，只有方法，没有数据（由struct承接）；</p>
<h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>接口是一组方法签名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> adRequest <span class="keyword">interface</span> &#123;</span><br><span class="line">	Process() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> sdkRequset <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> adxRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rtRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sdk sdkRequset)</span></span> Process() <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;sdk&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;sdk&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adx adxRequest)</span></span> Process() <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;adx&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;adx&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt rtRequest)</span></span> Process() <span class="type">string</span> &#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;rt&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;rt&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	requests := []adRequest&#123;sdkRequset&#123;&#125;, adxRequest&#123;&#125;, rtRequest&#123;&#125;&#125;</span><br><span class="line">	<span class="comment">/*for i := 0; i &lt; len(requests); i++ &#123;</span></span><br><span class="line"><span class="comment">		fmt.Print(requests[i].Process())</span></span><br><span class="line"><span class="comment">		fmt.Print(&quot;\n&quot;)</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">  <span class="keyword">for</span> _, ele := <span class="keyword">range</span> requests&#123;</span><br><span class="line">    fmt.Print(ele.Process())</span><br><span class="line">    fmt.Print(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h6><p>interface的断言</p>
<h5 id="同步原语和锁"><a href="#同步原语和锁" class="headerlink" title="同步原语和锁"></a>同步原语和锁</h5><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><h6 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h6><h5 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h5><h5 id="网络轮询器"><a href="#网络轮询器" class="headerlink" title="网络轮询器"></a>网络轮询器</h5><h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><h5 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h5><h5 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h5><h5 id="栈内存管理"><a href="#栈内存管理" class="headerlink" title="栈内存管理"></a>栈内存管理</h5><h4 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h4><h4 id="系统库"><a href="#系统库" class="headerlink" title="系统库"></a>系统库</h4>]]></content>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/2022/02/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E5%85%B6%E4%BB%96/zookeeper/</url>
    <content><![CDATA[<h3 id="zk节点类型"><a href="#zk节点类型" class="headerlink" title="zk节点类型"></a>zk节点类型</h3><ol>
<li>永久节点</li>
<li>永久有序节点【按照创建顺序会为每个节点末尾带上一个序号如：<code>root-1</code>】</li>
<li>瞬间节点（临时节点)【创建客户端与 Zookeeper 保持连接时节点存在，断开时则删除并会有相应的通知】</li>
<li>瞬间有序节点</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>服务注册发现（通过zk的临时节点）</li>
<li>分布式锁（通过zk的临时节点）</li>
<li>分布式通知（监听znode）</li>
<li>数据发布、订阅</li>
<li>服务命名</li>
</ol>
<span id="more"></span>

<h3 id="zk功能"><a href="#zk功能" class="headerlink" title="zk功能"></a>zk功能</h3><ol>
<li>zk赋予客户端（应用程序）监控节点的能力，即watch通知功能。</li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>组件</category>
      </categories>
      <tags>
        <tag>zk</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake了解</title>
    <url>/2023/03/08/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/cmake%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CMake 有两个主要阶段。第一个是“配置”步骤，其中 CMake 处理所有提供给它的输入并创建要执行的构建的内部表示。第二个阶段是“生成”步骤。在这个阶段创建实际的构建文件。第一步是 cmake -B build，称为配置阶段（configure），配置阶段可以通过 -D 设置缓存变量；第二步是cmake –build build，称为构建阶段，调用编译器来编译代码，-G 选项：指定要用的生成器</p>
<h3 id="cmake过程"><a href="#cmake过程" class="headerlink" title="cmake过程"></a>cmake过程</h3><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>在项目构建过程中都会使用 shell 级环境变量。项目通常有一个 PROJECT_ROOT 环境变量，它指向源代码树的根位置。环境变量也用于指向可选包或外部包。这种方法的问题在于，要使构建工作，每次执行构建时都需要设置所有这些外部变量。为了解决这个问题，CMake 有一个缓存文件，将构建所需的所有变量存储在一个地方。这些不是 shell 或环境变量，而是 CMake 变量。第一次为特定构建树运行 CMake 时，它会创建一个<code>CMakeCache.txt</code>存储该构建的所有持久变量的文件。由于该文件是构建树的一部分，因此在每次运行期间变量将始终对 CMake 可用。</p>
<h4 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h4><p>在配置步骤中，如果CMakeCache.txt在之前的运行中存在，CMake首先读取它。然后它读取CMakeLists.txt，在给CMake的源树的根中找到。在配置步骤中，CMakeLists.txt文件被CMake语言解析器解析。文件中的每个CMake命令都由命令模式对象执行。在此步骤中，可以使用include和add_subdirectory CMake命令解析其他CMakeLists.txt文件。对于CMake语言中可以使用的每个命令，CMake都有一个c++对象。命令示例包括add_library、if、add_executable、add_subdirectory和include。实际上，整个CMake语言都是通过调用命令来实现的。解析器只是将CMake输入文件转换为命令调用和作为命令参数的字符串列表。 </p>
<span id="more"></span>

<p>配置步骤本质上是“运行”用户提供的CMake代码。在执行了所有代码并计算了所有缓存变量值之后，CMake在内存中就有了要构建的项目的表示。这将包括为所选生成器创建最终构建文件所需的所有库、可执行文件、自定义命令和所有其他信息。此时，CMakeCache.txt文件将被保存到磁盘，以供将来运行CMake时使用。 </p>
<p>项目在内存中的表示是一组目标，这些目标只是一些可以构建的东西，比如库和可执行文件。CMake还支持自定义目标:用户可以定义他们的输入和输出，并提供在构建时运行的自定义可执行文件或脚本。CMake将每个目标存储在一个cmTarget对象中。这些对象依次存储在cmMakefile对象中，该对象基本上是源树给定目录中所有目标的存储位置。最终结果是包含cmTarget对象映射的cmMakefile对象树。</p>
<h4 id="生成步骤"><a href="#生成步骤" class="headerlink" title="生成步骤"></a>生成步骤</h4><p>一旦完成了配置步骤，就可以进行生成步骤。生成步骤是当CMake为用户选择的目标构建工具创建构建文件时。此时，目标(库、可执行文件、自定义目标)的内部表示形式被转换为IDE构建工具(如Visual Studio)的输入，或者由make执行的一组makefile。在配置步骤之后，CMake的内部表示是尽可能通用的，这样就可以在不同构建的工具之间共享尽可能多的代码和数据结构。</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/process.png" alt="【CMake流程概述】"></p>
<h4 id="构建级别"><a href="#构建级别" class="headerlink" title="构建级别"></a>构建级别</h4><p>CMake具有许多内置的构建配置，可用于编译工程。 这些配置指定了代码优化的级别，以及调试信息是否包含在二进制文件中。</p>
<p>CMAKE_BUILD_TYPE</p>
<p>这些优化级别，主要有：</p>
<ul>
<li><p>Release —— 不可以打断点调试，程序开发完成后发行使用的版本，占的体积小。 它对代码做了优化，因此速度会非常快，</p>
<p>在编译器中使用命令： <code>-O3 -DNDEBUG</code> 可选择此版本。</p>
</li>
<li><p>Debug ——调试的版本，体积大。</p>
<p>在编译器中使用命令： <code>-g</code> 可选择此版本。</p>
</li>
<li><p>MinSizeRel—— 最小体积版本</p>
<p>在编译器中使用命令：<code>-Os -DNDEBUG</code>可选择此版本。</p>
</li>
<li><p>RelWithDebInfo—— 既优化又能调试。</p>
<p>在编译器中使用命令：<code>-O2 -g -DNDEBUG</code>可选择此版本。</p>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="c-相关的cmake变量"><a href="#c-相关的cmake变量" class="headerlink" title="c++相关的cmake变量"></a>c++相关的cmake变量</h4><hr>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">CMAKE_CXX_STANDARD</span><br><span class="line">CMAKE_CXX_STANDARD_REQUIRED</span><br><span class="line">CMAKE_CXX_FLAGS</span><br><span class="line">CMAKE_CXX_FLAGS_RELEASE</span><br><span class="line">CMAKE_CXX_FLAGS_DEBUG</span><br></pre></td></tr></table></figure>

<p>CMAKE_CXX_STANDARD 变量</p>
<p>CMAKE_CXX_STANDARD_REQUIRED 是 BOOL 类型，可以为 ON 或 OFF，默认 OFF。他表示是否一定要支持你指定的 C++ 标准：如果为 OFF 则 CMake 检测到编译器不支持 C++17 时不报错，而是默默调低到 C++14 给你用；</p>
<blockquote>
<p>最好是在 project 指令前设置 CMAKE_CXX_STANDARD 这一系列变量，这样 CMake 可以在 project 函数里对编译器进行一些检测，看看他能不能支持 C++17 的特性。请勿直接修改 CMAKE_CXX_FLAGS 来添加 -std&#x3D;c++17</p>
</blockquote>
<h6 id="c-新标准相关选项"><a href="#c-新标准相关选项" class="headerlink" title="c++新标准相关选项"></a>c++新标准相关选项</h6><p>CMake支持传递一个变量给函数CMAKE_CXX_COMPILER_FLAG来编译程序。 然后将结果存储在您传递的变量中。编译器选项</p>
<p>CMAKE_C_COMPILER用于编译c代码的程序；CMAKE_CXX_COMPILER用于编译c++；CMAKE_LINKER用于链接二进制程序。</p>
<p>确定编译器是否支持标志后，即可使用标准cmake方法将此标志添加到目标。 在此示例中，我们使用CMAKE_CXX_FLAGS将标志（c++标准）传播给所有目标。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11&quot;</span>)</span><br></pre></td></tr></table></figure>

<h6 id="编译标志"><a href="#编译标志" class="headerlink" title="编译标志"></a>编译标志</h6><p>这些编译设置都在CMAKE_CXX_FLAGS变量中。（C语言编译选项是CMAKE_C_FLAGS）</p>
<p>可以通过target_compile_definitions（）函数设置某个目标的编译标志。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(cmake_examples_compile_flags</span><br><span class="line">    PRIVATE EX3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>编译器选项，还可以使用target_compile_options（）函数【不建议使用】</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(&lt;<span class="keyword">target</span>&gt; [BEFORE]</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure>

<p>是给 <code>target</code> 添加编译选项， <code>target</code> 指的是由 <code>add_executable()</code>产生的可执行文件或 <code>add_library()</code>添加进来的库。<code>&lt;INTERFACE|PUBLIC|PRIVATE&gt;</code>指的是<code>[items...]</code> 选项可以传播的范围， <code>PUBLIC and INTERFACE</code>会传播 <code>&lt;target&gt;</code>的 <a href="https://cmake.org/cmake/help/v3.0/prop_tgt/INTERFACE_COMPILE_DEFINITIONS.html#prop_tgt:INTERFACE_COMPILE_DEFINITIONS">INTERFACE_COMPILE_DEFINITIONS</a> 属性， <code>PRIVATE and PUBLIC</code> 会传播 <code>target</code> 的 <a href="https://cmake.org/cmake/help/v3.0/prop_tgt/COMPILE_DEFINITIONS.html#prop_tgt:COMPILE_DEFINITIONS">COMPILE_DEFINITIONS </a>属性。</p>
<h6 id="默认变量"><a href="#默认变量" class="headerlink" title="默认变量"></a>默认变量</h6><h4 id="Cmake普通变量【可以把所有不确定的地方都套上一层引号】"><a href="#Cmake普通变量【可以把所有不确定的地方都套上一层引号】" class="headerlink" title="Cmake普通变量【可以把所有不确定的地方都套上一层引号】"></a>Cmake普通变量【可以把所有不确定的地方都套上一层引号】</h4><hr>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">cmake [&lt;options&gt;] (&lt;path-to-source&gt; | &lt;path-to-existing-build&gt;)</span><br><span class="line">cmake [(-D&lt;var&gt;=&lt;value&gt;)...] -P &lt;cmake-script-<span class="keyword">file</span>&gt;</span><br><span class="line">cmake --build &lt;dir&gt; [&lt;options&gt;] [-- &lt;build-tool-options&gt;...]</span><br><span class="line">cmake -E &lt;<span class="keyword">command</span>&gt; [&lt;options&gt;]</span><br><span class="line">cmake --find-package &lt;options&gt;...</span><br></pre></td></tr></table></figure>

<p>Cmakelists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>) <span class="comment">#设置CMake最小版本</span></span><br><span class="line"><span class="keyword">project</span> (hello_cmake) <span class="comment">#设置工程名</span></span><br><span class="line"><span class="keyword">add_executable</span>(hello_cmake main.cpp) <span class="comment">#生成可执行文件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#PROJECT_SOURCE_DIR指工程顶层目录</span></span><br><span class="line"><span class="comment">#PROJECT_Binary_DIR指编译目录</span></span><br><span class="line"><span class="comment">#PRIVATE指定了库的范围，下一节讲</span></span><br></pre></td></tr></table></figure>

<p>CMake语法指定了许多变量，可用于帮助您在项目或源代码树中找到有用的目录。 其中一些包括：</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>InfoInfo–</th>
</tr>
</thead>
<tbody><tr>
<td>CMAKE_SOURCE_DIRCMAKE_SOURCE_DIR</td>
<td>根源代码目录，工程顶层目录。暂认为就是PROJECT_SOURCE_DIR根源代码目录，工程顶层目录。暂认为就是PROJECT_SOURCE_DIR</td>
</tr>
<tr>
<td>CMAKE_CURRENT_SOURCE_DIR</td>
<td>当前处理的 CMakeLists.txt 所在的路径</td>
</tr>
<tr>
<td>PROJECT_SOURCE_DIR</td>
<td>工程顶层目录</td>
</tr>
<tr>
<td>CMAKE_BINARY_DIR</td>
<td>运行cmake的目录。外部构建时就是build目录</td>
</tr>
<tr>
<td>CMAKE_CURRENT_BINARY_DIR</td>
<td>The build directory you are currently in.当前所在build目录</td>
</tr>
<tr>
<td>PROJECT_BINARY_DIR</td>
<td>暂认为就是CMAKE_BINARY_DIR</td>
</tr>
<tr>
<td>PROJECT_NAME</td>
<td>当前project（）设置的项目的名称。</td>
</tr>
<tr>
<td>CMAKE_PROJECT_NAME</td>
<td>由project（）命令设置的第一个项目的名称，即顶层项目。</td>
</tr>
<tr>
<td>PROJECT_SOURCE_DIR</td>
<td>当前项目的源文件目录。</td>
</tr>
<tr>
<td>PROJECT_BINARY_DIR</td>
<td>当前项目的构建目录。</td>
</tr>
<tr>
<td>name_SOURCE_DIR</td>
<td>在此示例中，创建的源目录为 <code>sublibrary1_SOURCE_DIR</code>, <code>sublibrary2_SOURCE_DIR</code>, and <code>subbinary_SOURCE_DIR</code></td>
</tr>
<tr>
<td>name_BINARY_DIR</td>
<td>本工程的二进制目录是<code>sublibrary1_BINARY_DIR</code>, <code>sublibrary2_BINARY_DIR</code>,和 <code>subbinary_BINARY_DIR</code></td>
</tr>
</tbody></table>
<h4 id="cmake-cache变量"><a href="#cmake-cache变量" class="headerlink" title="cmake cache变量"></a>cmake cache变量</h4><p>set(<variable> <value>… CACHE <type> <docstring> [FORCE])</p>
<ul>
<li>ariable：变量名称</li>
<li>value：变量值列表</li>
<li>CACHE：cache变量的标志</li>
<li>type：变量类型，取决于变量的值。类型分为：BOOL、FILEPATH、PATH、STRING、INTERNAL</li>
<li>docstring：必须是字符串，作为变量概要说明</li>
<li>FORCE：强制选项，强制修改变量值</li>
</ul>
<p>使用：</p>
<ol>
<li><p>定义缓存变量时，可以不加FORCE选项：</p>
<p>set(MY_GLOBAL_VAR_STRING_NOFORCE “abcdef” CACHE STRING “定义一个STRING缓存变量”)</p>
</li>
<li><p>修改缓存变量时，一定要加FORCE选项，否则修改无效：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改定义时不加FORCE的缓存变量(不加FORCE选项方式修改)</span></span><br><span class="line"><span class="keyword">set</span>(MY_GLOBAL_VAR_STRING_NOFORCE <span class="string">&quot;modify_abcdef_without_force&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;修改一个STRING缓存变量&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MY_GLOBAL_VAR_STRING_NOFORCE: $&#123;MY_GLOBAL_VAR_STRING_NOFORCE&#125;&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 修改定义时不加FORCE的缓存变量(加FORCE选项方式修改)</span></span><br><span class="line"><span class="keyword">set</span>(MY_GLOBAL_VAR_STRING_NOFORCE <span class="string">&quot;modify_abcdef_with_force&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;修改一个STRING缓存变量&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MY_GLOBAL_VAR_STRING_NOFORCE: $&#123;MY_GLOBAL_VAR_STRING_NOFORCE&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># 参考：https://www.cnblogs.com/Braveliu/p/15614013.html</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
</li>
<li><p>Cache变量都会保存在CMakeCache.txt文件中。</p>
</li>
<li><p>不论定义或修改缓存变量时，建议都加上FORCE选项。结合1、2项所得。</p>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>在前面的示例中，运行make命令时，输出仅显示构建状态。 要查看用于调试目的的完整输出，可以在运行make时添加make VERBOSE &#x3D; 1或者set(CMAKE_VERBOSE_MAKEFILE ON)标志.在顶层<code>CMakeLists.txt</code>里set(CMAKE_VERBOSE_MAKEFILE ON)<code>或者 </code>cmake。再make VERBOSE&#x3D;1 或 <code>cmake -DCMAKE_VERBOSE_MAKEFILE:BOOL=ON。再  make</code></p>
<p>最好：cmake -DCMAKE_RULE_MESSAGES:BOOL&#x3D;OFF -DCMAKE_VERBOSE_MAKEFILE:BOOL&#x3D;ON .   再   make –no-print-directory最后这种方式可以减少很多无用的信息，如：<code>make[1]: Entering directory</code> and <code>make[1]: Leaving directory</code></p>
<p>注意，你可以使用 -DCMAKE_EXPORT_COMPILE_COMMANDS&#x3D;ON 选项来查看最干净的编译选项，它会生成一个 compile_commands.json 文件。</p>
<p>想仔细体会一下，可以在CMakeLists中，利用message（）命令输出一下这些变量。</p>
<p>另外，这些变量不仅可以在CMakeLists中使用，同样可以在源代码.cpp中使用。</p>
<h4 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories()"></a>include_directories()</h4><p>Include_directories (x&#x2F;y)影响目录作用域。这个CMakeList中的所有目标，以及在调用点之后添加的所有子目录中的目标，都将把路径x&#x2F;y添加到它们的包含路径中。 </p>
<p>Target_include_directories (t x&#x2F;y)具有目标作用域—它将x&#x2F;y添加到目标t的包含路径中。 </p>
<p>如果所有目标都使用包含目录，则需要前者。如果路径特定于目标，或者希望更好地控制路径的可见性，则需要后一种方法。后者来自target_include_directories()支持PRIVATE、PUBLIC和INTERFACE限定符</p>
<h4 id="target-include-directories（）添加头文件"><a href="#target-include-directories（）添加头文件" class="headerlink" title="target_include_directories（）添加头文件"></a>target_include_directories（）添加头文件</h4><p>当您有其他需要包含的文件夹（文件夹里有头文件）时，可以使用以下命令使编译器知道它们： target_include_directories（）。 编译此目标时，这将使用-I标志将这些目录添加到编译器中，例如 -I &#x2F;目录&#x2F;路径</p>
<h4 id="TARGET"><a href="#TARGET" class="headerlink" title="TARGET"></a>TARGET</h4><h4 id="add-executable"><a href="#add-executable" class="headerlink" title="add_executable()"></a>add_executable()</h4><p>在cmake中不管是生成library还是binary，都可以称作构建target</p>
<h4 id="add-library（）"><a href="#add-library（）" class="headerlink" title="add_library（）"></a>add_library（）</h4><p>cmake变量BUILD_SHARED_LIB 是一个全局变量，主要是用于控制cmake是否可以生成动态so</p>
<p>默认情况下BUILD_SHARED_LIB变量打开状态为on，即默认使用add_library是创建的动态lib，值为on。此时除非是cmakelist文件中特别制定需要生成静态lib，否则默认就是生成的动态lib，如果此时想要强制生成静态so则需要使用,如果BUILD_SHARED_LIB 设置为off，则关闭生成动态so，默认为静态lib文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(&lt;<span class="keyword">target</span> &gt; STATIC &lt;&gt;)</span><br></pre></td></tr></table></figure>



<h6 id="编译静态库-x2F-编译动态库"><a href="#编译静态库-x2F-编译动态库" class="headerlink" title="编译静态库&#x2F;编译动态库"></a>编译静态库&#x2F;编译动态库</h6><p>add_library（）函数用于从某些源文件创建一个库，默认生成在构建文件夹。 写法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello_library STATIC</span><br><span class="line">    src/Hello.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在add_library调用中包含了源文件，用于创建名称为libhello_library.a的静态库。</p>
<blockquote>
<p>如前面的示例所述，将源文件直接传递给add_library调用,这是modern CMake的建议,而不是先把Hello.cpp赋给一个变量）</p>
</blockquote>
<p>add_library（）函数用于从某些源文件创建一个动态库，默认生成在构建文件夹。 写法如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(hello_library SHARED</span><br><span class="line">    src/Hello.cpp</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在add_library调用中包含了源文件，用于创建名称为libhello_library.so的动态库。</p>
<table>
<thead>
<tr>
<th>NOTE</th>
<th>如前面的示例所述，将源文件直接传递给add_library调用，这是modern CMake的建议。（而不是先把Hello.cpp赋给一个变量）</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h6 id="设置库的范围"><a href="#设置库的范围" class="headerlink" title="设置库的范围"></a>设置库的范围</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD_LIBRARY(glog STATIC IMPORTED GLOBAL)</span><br><span class="line">SET_PROPERTY(TARGET glog PROPERTY IMPORTED_LOCATION $&#123;THIRD_PARTY_PATH&#125;/lib/libglog.a)</span><br><span class="line">ADD_DEPENDENCIES(extern_glog gflags)</span><br><span class="line">ADD_DEPENDENCIES(glog extern_glog)</span><br></pre></td></tr></table></figure>

<h6 id="alais库"><a href="#alais库" class="headerlink" title="alais库"></a>alais库</h6><h4 id="optional"><a href="#optional" class="headerlink" title="optional()"></a>optional()</h4><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p>set(<variable> <value>… CACHE <type> <docstring> [FORCE])</p>
<p>该命令可以为普通变量、缓存变量、环境变量赋值,通过unset()取消</p>
<p>环境变量</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;&lt;variable&gt;&#125; [&lt;value&gt;])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>set(ENV&#123;variable_name&#125; value)</code> 设置环境变量</li>
<li><code>$ENV&#123;variable_name&#125;</code> 获取环境变量</li>
</ul>
<h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><p>CMake支持使用find_package（）函数查找这些工具的路径。这将从CMAKE_MODULE_PATH中的文件夹列表中搜索格式为“ FindXXX.cmake”的CMake模块。 在linux上，默认搜索路径将是&#x2F; usr &#x2F; share &#x2F; cmake &#x2F; Modules。 在我的系统上，这包括对大约142个通用第三方库的支持。</p>
<h4 id="子项目"><a href="#子项目" class="headerlink" title="子项目"></a>子项目</h4><h6 id="引用子项目中的库"><a href="#引用子项目中的库" class="headerlink" title="引用子项目中的库"></a>引用子项目中的库</h6><p>如果子项目创建了一个库，则其他项目可以通过在target_link_libraries（）命令中调用该项目的名称来引用该库。 这意味着您不必引用新库的完整路径，而是将其添加为依赖项。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(subbinary</span><br><span class="line">    PUBLIC</span><br><span class="line">        sublibrary1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>或者，您可以创建一个别名目标，该目标允许您在上下文（其实就是某个目标的绰号）中引用该目标。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(sublibrary2)</span><br><span class="line"><span class="keyword">add_library</span>(sub::lib2 ALIAS sublibrary2)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(subbinary</span><br><span class="line">    sub::lib2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h6 id="包含子项目的目录"><a href="#包含子项目的目录" class="headerlink" title="包含子项目的目录"></a>包含子项目的目录</h6><p>从cmake v3开始从子项目添加库时，无需将项目include目录添加到二进制文件的include目录中。</p>
<p>创建库时，这由target_include_directories（）命令中的作用域控制。 在此示例中，因为子二进制可执行文件链接了sublibrary1和sublibrary2库，所以当它们与库的PUBLIC和INTERFACE范围一起导出时，它将自动包含$ {sublibrary1_SOURCE_DIR} &#x2F; inc和$ {sublibrary2_SOURCE_DIR} &#x2F; inc文件夹。（这个地方设及到了PUBLIC和INTERFACE的使用，本电子书的CMake-scope是讲这个的）</p>
<h4 id="protocol-bufer"><a href="#protocol-bufer" class="headerlink" title="protocol bufer"></a>protocol bufer</h4><h4 id="get-filename-component"><a href="#get-filename-component" class="headerlink" title="get_filename_component"></a>get_filename_component</h4><p>cmake获取’文件名’的’特定’部分</p>
<h4 id="ninja"><a href="#ninja" class="headerlink" title="ninja"></a>ninja</h4><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串相关的操作，比如转换为小写、替换、查找</p>
<h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><h4 id="configure-file"><a href="#configure-file" class="headerlink" title="configure_file"></a>configure_file</h4><p>将文件复制到另一个位置并修改其内容。</p>
<p>当然，这里的修改其内容也不是任意地修改，也是遵循一定的规则：将input文件复制到output文件，并在输入文件内容中的变量，替换引用为@VAR@或${VAR}的变量值。每个变量引用将替换为该变量的当前值，如果未定义该变量，则为空字符串。</p>
<p>可能有些绕头，再浅显一点：configure_file，复制一份输入文件到输出文件，替换输入文件中被@VAR@或者${VAR}引用的变量值。也就是说，让普通文件，也能使用CMake中的变量。</p>
<h4 id="install"><a href="#install" class="headerlink" title="install"></a>install</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(TARGETS targets...</span><br><span class="line">[[ARCHIVE|LIBRARY|RUNTIME]</span><br><span class="line">[DESTINATION &lt;dir&gt;]</span><br><span class="line">[PERMISSIONS permissions...]</span><br><span class="line">[CONFIGURATIONS</span><br><span class="line">[Debug|Release|...]]</span><br><span class="line">[COMPONENT &lt;component&gt;]</span><br><span class="line">[OPTIONAL]</span><br><span class="line">] [...])</span><br></pre></td></tr></table></figure>

<p>DESTINATION定义了安装的路径，如果路径以&#x2F;开头，那么指的是绝对路径，这时候CMAKE_INSTALL_PREFIX其实就无效了。如果你希望使用CMAKE_INSTALL_PREFIX来定义安装路径，就要写成相对路径，即不要以&#x2F;开头，那么安装后的路径就是${CMAKE_INSTALL_PREFIX}&#x2F;&lt;DESTINATION定义的路径&gt;</p>
<h4 id="execute-process"><a href="#execute-process" class="headerlink" title="execute_process"></a>execute_process</h4><h4 id="add-compile-options"><a href="#add-compile-options" class="headerlink" title="add_compile_options"></a>add_compile_options</h4><p>add_compile_options函数来设置编译器选项，不过它是针对所有编译器的（包括c和c++编译器）</p>
<p>add_compile_options是用来配置当前目录和子目录的所有目标文件的options。如果有一个库需要让所有的目标文件链接的时候，使用此命令非常方便。所有添加的options可以通过<a href="https://cmake.org/cmake/help/v3.17/prop_dir/COMPILE_OPTIONS.html#prop_dir:COMPILE_OPTIONS"><code>COMPILE_OPTIONS</code></a>属性查看。<code>add_compile_options</code>作用的范围太广，一般很少使用。</p>
<p>CMAKE_CXX_FLAGS是配置所有C++目标文件的flags。可以传递一些参数比如warnings的等级，使用的C++标准等。对C语言的目标文件没有效，因此用户可为他们两种文件设置不同的flags。</p>
<h4 id="set-target-properties"><a href="#set-target-properties" class="headerlink" title="set_target_properties"></a>set_target_properties</h4><h4 id="aux-source-directory"><a href="#aux-source-directory" class="headerlink" title="aux_source_directory( )"></a>aux_source_directory(<dir> <variable>)</h4><p>收集指定目录中所有源文件的名称，并将列表存储在提供的<variable>变量中，该命令旨在供使用显式模板实例化的项目使用。 模板实例化文件可以存储在Templates子目录中，并使用此命令自动收集，以避免手动列出所有实例化。</p>
<h4 id="add-subdirectory-source-dir-binary-dir-EXCLUDE-FROM-ALL"><a href="#add-subdirectory-source-dir-binary-dir-EXCLUDE-FROM-ALL" class="headerlink" title="add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL]))"></a>add_subdirectory(source_dir [binary_dir] [<code>EXCLUDE_FROM_ALL</code>]))</h4><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存 放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除，比如，工程 的 example，可能就需要工程构建完成后，再进入 example 目录单独进行构建(当然，你 也可以通过定义依赖来解决此类问题)。</p>
<p><strong><code>source_dir</code></strong><br> <strong>必选参数</strong>。该参数指定一个子目录，子目录下应该包含<code>CMakeLists.txt</code>文件和代码文件。子目录可以是相对路径也可以是绝对路径，如果是相对路径，则是相对当前目录的一个相对路径。</p>
<p><strong><code>binary_dir</code></strong><br> <strong>可选参数</strong>。该参数指定一个目录，用于存放输出文件。可以是相对路径也可以是绝对路径，如果是相对路径，则是相对当前输出目录的一个相对路径。如果该参数没有指定，则默认的输出目录使用<code>source_dir</code>。</p>
<p><strong><code>EXCLUDE_FROM_ALL</code></strong><br> <strong>可选参数</strong>。当指定了该参数，则子目录下的目标不会被父目录下的目标文件包含进去，父目录的<code>CMakeLists.txt</code>不会构建子目录的目标文件，必须在子目录下显式去构建。<code>例外情况：当父目录的目标依赖于子目录的目标，则子目录的目标仍然会被构建出来以满足依赖关系（例如使用了target_link_libraries）</code>。</p>
<h4 id="ExternalProject"><a href="#ExternalProject" class="headerlink" title="ExternalProject"></a>ExternalProject</h4><p><em><a href="https://cmake.org/cmake/help/v3.5/module/ExternalProject.html">https://cmake.org/cmake/help/v3.5/module/ExternalProject.html</a></em> </p>
<p><code>ExternalProject_Add</code>有许多选项，可用于外部项目的配置和编译等所有方面</p>
<h5 id="dir"><a href="#dir" class="headerlink" title="dir"></a>dir</h5><p>If any of the above <code>..._DIR</code> options are not specified, their defaults are computed as follows. If the <code>PREFIX</code> option is given or the <code>EP_PREFIX</code> directory property is set, then an external project is built and installed under the specified prefix:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TMP_DIR      = &lt;prefix&gt;/tmp</span><br><span class="line">STAMP_DIR    = &lt;prefix&gt;/src/&lt;name&gt;-stamp</span><br><span class="line">DOWNLOAD_DIR = &lt;prefix&gt;/src</span><br><span class="line">SOURCE_DIR   = &lt;prefix&gt;/src/&lt;name&gt;</span><br><span class="line">BINARY_DIR   = &lt;prefix&gt;/src/&lt;name&gt;-build</span><br><span class="line">INSTALL_DIR  = &lt;prefix&gt;</span><br><span class="line">LOG_DIR      = &lt;STAMP_DIR&gt;</span><br></pre></td></tr></table></figure>

<p>Otherwise, if the <code>EP_BASE</code> directory property is set then components of an external project are stored under the specified base:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TMP_DIR      = &lt;base&gt;/tmp/&lt;name&gt;</span><br><span class="line">STAMP_DIR    = &lt;base&gt;/Stamp/&lt;name&gt;</span><br><span class="line">DOWNLOAD_DIR = &lt;base&gt;/Download/&lt;name&gt;</span><br><span class="line">SOURCE_DIR   = &lt;base&gt;/Source/&lt;name&gt;</span><br><span class="line">BINARY_DIR   = &lt;base&gt;/Build/&lt;name&gt;</span><br><span class="line">INSTALL_DIR  = &lt;base&gt;/Install/&lt;name&gt;</span><br><span class="line">LOG_DIR      = &lt;STAMP_DIR&gt;</span><br></pre></td></tr></table></figure>

<p>If no <code>PREFIX</code>, <code>EP_PREFIX</code>, or <code>EP_BASE</code> is specified, then the default is to set <code>PREFIX</code> to <code>&lt;name&gt;-prefix</code>. Relative paths are interpreted with respect to <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_CURRENT_BINARY_DIR.html#variable:CMAKE_CURRENT_BINARY_DIR"><code>CMAKE_CURRENT_BINARY_DIR</code></a> at the point where <code>ExternalProject_Add()</code> is called.</p>
<h5 id="include-ExternalProject"><a href="#include-ExternalProject" class="headerlink" title="include(ExternalProject)"></a>include(ExternalProject)</h5><h5 id="ExternalProject-Add（）"><a href="#ExternalProject-Add（）" class="headerlink" title="ExternalProject_Add（）"></a>ExternalProject_Add（）</h5><p>函数创建一个自定义目标，以实现外部项目的下载、更新&#x2F;修补、配置、构建、安装和测试步骤。它允许<strong>在构建时</strong>检索项目的依赖项。本文主要讲解常用的一些选项。其他选项看参考<a href="https://cmake.org/cmake/help/latest/module/ExternalProject.html">官方文档</a>。</p>
<h5 id="Download-Step-Options"><a href="#Download-Step-Options" class="headerlink" title="Download Step Options"></a>Download Step Options</h5><h6 id="DOWNLOAD-COMMAND-…-为提供空字符串有效地禁用下载步骤。"><a href="#DOWNLOAD-COMMAND-…-为提供空字符串有效地禁用下载步骤。" class="headerlink" title="DOWNLOAD_COMMAND … 为提供空字符串有效地禁用下载步骤。"></a>DOWNLOAD_COMMAND <cmd>… 为<cmd>提供空字符串有效地禁用下载步骤。</h6><p>多个url会轮询下载，直到有一个成功；</p>
<p>可以从git下载</p>
<p>Mercurial和cvs</p>
<h5 id="Update-Step-Options"><a href="#Update-Step-Options" class="headerlink" title="Update Step Options"></a>Update Step Options</h5><h5 id="Patch-Step-Options"><a href="#Patch-Step-Options" class="headerlink" title="Patch Step Options"></a>Patch Step Options</h5><h5 id="Configure-Step-Options"><a href="#Configure-Step-Options" class="headerlink" title="Configure Step Options"></a>Configure Step Options</h5><p>CONFIGURE_COMMAND &lt; cmd &gt;… 【该命令在该阶段优先级最高】</p>
<p>默认的configure命令运行CMake，并根据主项目提供一些选项。添加的选项通常只需要使用与主项目相同的生成器，但是可以使用CMAKE_GENERATOR选项来覆盖该选项。项目负责添加任何工具链细节，标志或其他它想从主项目中重用或指定的设置(参见下面的CMAKE_ARGS, CMAKE_CACHE_ARGS和CMAKE_CACHE_DEFAULT_ARGS)。</p>
<h5 id="Build-Step-Options"><a href="#Build-Step-Options" class="headerlink" title="Build Step Options"></a>Build Step Options</h5><h5 id="Install-Step-Options"><a href="#Install-Step-Options" class="headerlink" title="Install Step Options"></a>Install Step Options</h5><h5 id="Test-Step-Options"><a href="#Test-Step-Options" class="headerlink" title="Test Step Options"></a>Test Step Options</h5><h5 id="Output-Logging-Options"><a href="#Output-Logging-Options" class="headerlink" title="Output Logging Options"></a>Output Logging Options</h5><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><em>#为啥一定是大写呢</em></p>
<p>ExternalProject_Add(SPDLOG 。。。）</p>
<h4 id="FetchContent"><a href="#FetchContent" class="headerlink" title="FetchContent"></a>FetchContent</h4><p><em><a href="https://cmake.org/cmake/help/v3.11/module/FetchContent.html">https://cmake.org/cmake/help/v3.11/module/FetchContent.html</a></em> </p>
<p><a href="https://cmake.org/cmake/help/latest/module/FetchContent.html">FetchContent</a> 在 configure 阶段下载文件或者项目</p>
<h5 id="include-FetchContent"><a href="#include-FetchContent" class="headerlink" title="include(FetchContent)"></a>include(FetchContent)</h5><h5 id="FetchContent-Declare"><a href="#FetchContent-Declare" class="headerlink" title="FetchContent_Declare()"></a>FetchContent_Declare()</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">FetchContent_Declare(</span><br><span class="line">  &lt;name&gt;</span><br><span class="line">  &lt;contentOptions&gt;...</span><br><span class="line">  [SYSTEM]</span><br><span class="line">  [OVERRIDE_FIND_PACKAGE |</span><br><span class="line">   FIND_PACKAGE_ARGS args...]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><contentOptions>可以是ExternalProject_Add()命令理解的任何下载、更新或补丁选项。配置、构建、安装和测试步骤被显式禁用，因此与它们相关的选项将被忽略。SOURCE_SUBDIR选项是一个例外，参见c了解它如何影响行为的详细信息。</p>
<h5 id="FetchContent-MakeAvailable"><a href="#FetchContent-MakeAvailable" class="headerlink" title="FetchContent_MakeAvailable"></a>FetchContent_MakeAvailable</h5><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">FetchContent_MakeAvailable(&lt;name1&gt; [&lt;name2&gt;...])</span><br></pre></td></tr></table></figure>

<h5 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h5><p>FETCHCONTENT_BASE_DIR</p>
<p>在大多数情况下，所保存的详细信息没有指定与用于内部子构建、最终源代码和构建区域的目录相关的任何选项。通常最好将这些决定留给FetchContent模块来代表项目处理。FETCHCONTENT_BASE_DIR缓存变量控制收集所有内容填充目录的点，但在大多数情况下，开发人员不需要更改这一点。默认位置是${CMAKE_BINARY_DIR}&#x2F;_deps，</p>
<h4 id="find-package"><a href="#find-package" class="headerlink" title="find_package()"></a>find_package()</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(&lt;package&gt; [version] [EXACT] [QUIET] [MODULE]</span><br><span class="line">             [REQUIRED] [[COMPONENTS] [components...]]</span><br><span class="line">             [OPTIONAL_COMPONENTS components...]</span><br><span class="line">             [NO_POLICY_SCOPE])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>c++程序运行的时候会通过<code>LD_LIBRARY_PATH</code>这个环境变量寻找<strong>除了默认路径之外的其他路径</strong>的动态链接库，默认路径就是类似于<code>/usr/lib</code>这种的在系统库中的动态链接库文件。</p>
<p>动态链接库的寻找顺序:</p>
<ul>
<li>1.编译目标代码时指定的动态库搜索路径；</li>
<li>2.环境变量LD_LIBRARY_PATH指定的动态库搜索路径；</li>
<li>3.配置文件&#x2F;etc&#x2F;ld.so.conf中指定的动态库搜索路径；</li>
<li>4.默认的动态库搜索路径&#x2F;lib和&#x2F;usr&#x2F;lib；</li>
</ul>
</blockquote>
<p>怎么find，find 的顺序是啥样的，find什么?得到什么信息</p>
<h5 id="Module模式"><a href="#Module模式" class="headerlink" title="Module模式"></a>Module模式</h5><p>查找路径有两个，在这两个路径下查找；具体是查找Find<package>.cmake</p>
<p>路径1：环境变量CMAKE_MODULE_PATH所代表的路径【CMAKE_MODULE_PATH】</p>
<p>路径2：&#x2F;usr&#x2F;local&#x2F;share&#x2F;cmake-3.23&#x2F;Modules&#x2F;【CMAKE_ROOT】</p>
<p>message(STATUS “CMAKE_MODULE_PATH &#x3D; ${CMAKE_MODULE_PATH}”)</p>
<p> message(STATUS “CMAKE_ROOT &#x3D; ${CMAKE_ROOT}”)</p>
<h5 id="Config模式"><a href="#Config模式" class="headerlink" title="Config模式"></a>Config模式</h5><p>如果Module模式搜索失败，没有找到对应的<code>Find&lt;LibraryName&gt;.cmake</code>文件，则转入Config模式进行搜索。</p>
<p>只有在<code>find_package()</code>中指定<strong>CONFIG</strong>、<strong>NO_MODULE</strong>等关键字，或者<strong>Module</strong>模式查找失败后才会进入到<strong>Config</strong>模式。</p>
<p>CMake 对 Config file 的命名是有规定的，对于<code>find_package(ABC)</code>这样一条命令，CMake 只会去寻找<code>ABCConfig.cmake</code>或是<code>abc-config.cmake</code>。在 Linux 下寻找路径包括<code>/usr/lib/cmake</code>以及&#96;&#x2F;usr&#x2F;lib&#x2F;local&#x2F;cmake。</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/1746850-20201116091250447-2073530575.png" alt="1746850-20201116091250447-2073530575"></p>
<h4 id="target-link-libraries"><a href="#target-link-libraries" class="headerlink" title="target_link_libraries()"></a>target_link_libraries()</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target_link_libraries(&lt;target&gt;</span><br><span class="line">                      &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...</span><br><span class="line">                     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure>





<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>属性有点像变量，但它依附在某个 target 或者文件、目录上。许多属性的初始值来自于 CMAKE_ 开头的变量，例如设置 CMAKE_CXX_STANDARD，将会设置 target 的 CXX_STANDARD 属性初始值。<br>set_property 用于设置属性，get_property 用于获取属性。参看 cmake-properties 查阅有哪些属性</p>
<h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>在 CMake 中可以配合其他工具</p>
<p>CCache，使用它来加快编译速度<br>Clang tidy，对你的代码做静态扫描<br>Include what you use, 检查冗余头文件<br>Clang-format，很不幸 CMake 没法直接使用 Clang-format，但是可以通过一些小技巧将它嵌入到 CMake 流程中来。参考这里还有这里</p>
<h4 id="CMake-Modules"><a href="#CMake-Modules" class="headerlink" title="CMake Modules"></a>CMake Modules</h4><h6 id="CMAKE-BUILD-TYPE"><a href="#CMAKE-BUILD-TYPE" class="headerlink" title="CMAKE_BUILD_TYPE"></a>CMAKE_BUILD_TYPE</h6><p>\1. Debug\2. MinSizeRel\3. RelWithDebInfo\4. Release</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> (CMAKE_BUILD_TYPE <span class="string">&quot;RelWithDebInfo&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><p>在add_library(hello_shared_lib SHARED)中指定是SHARED</p>
<h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><h5 id="cmake-–build-x2F-build-–parallel-2"><a href="#cmake-–build-x2F-build-–parallel-2" class="headerlink" title="cmake –build .&#x2F;build –parallel 2"></a>cmake –build .&#x2F;build –parallel 2</h5><p><img src="https://img-blog.csdnimg.cn/d4d58035a46a4d41b29f75527603f627.png" alt="img"></p>
<h5 id="cmake-–build-x2F-build-x2F-–verbose-调试构建"><a href="#cmake-–build-x2F-build-x2F-–verbose-调试构建" class="headerlink" title="cmake –build .&#x2F;build&#x2F; –verbose 调试构建"></a>cmake –build .&#x2F;build&#x2F; –verbose 调试构建</h5><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul>
<li><em>cmake –help-command-list | grep find</em>【<em>cmake –help-command find_library</em>】</li>
<li>cmake –help-variable-list  | grep CMAKE | grep HOST</li>
<li>cmake –help-property-list | grep NAME【cmake –help-property OUTPUT_NAME】</li>
<li>cmake –help-module FindBoost | head -40</li>
</ul>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><p><input disabled="" type="checkbox"> </p>
<h5 id="could-not-load-cache【cmake-–build-x2F-build-x2F-】"><a href="#could-not-load-cache【cmake-–build-x2F-build-x2F-】" class="headerlink" title="could not load cache【cmake –build .&#x2F;build&#x2F;】"></a>could not load cache【cmake –build .&#x2F;build&#x2F;】</h5><p>先用cmake -B .&#x2F;build生成CMakeCache.txt等相关的问题，然后cmake –build .&#x2F;build</p>
</li>
<li><p><input disabled="" type="checkbox"> </p>
<h5 id="PRIVATE和target-include-directories关系-INTERFACE-INCLUDE-DIRECTORIES"><a href="#PRIVATE和target-include-directories关系-INTERFACE-INCLUDE-DIRECTORIES" class="headerlink" title="PRIVATE和target_include_directories关系,INTERFACE_INCLUDE_DIRECTORIES"></a>PRIVATE和target_include_directories关系,INTERFACE_INCLUDE_DIRECTORIES</h5></li>
<li><p><input disabled="" type="checkbox"> </p>
<h5 id="怎么把动态库指定到build目录下，而不是lib下"><a href="#怎么把动态库指定到build目录下，而不是lib下" class="headerlink" title="怎么把动态库指定到build目录下，而不是lib下"></a>怎么把动态库指定到build目录下，而不是lib下</h5></li>
<li><p><input disabled="" type="checkbox"> </p>
<h5 id="generate-export-header"><a href="#generate-export-header" class="headerlink" title="generate_export_header"></a>generate_export_header</h5></li>
<li><p><input disabled="" type="checkbox"> </p>
<h5 id="INTERFACE-、PUBLIC、PRIVATE"><a href="#INTERFACE-、PUBLIC、PRIVATE" class="headerlink" title="INTERFACE 、PUBLIC、PRIVATE"></a>INTERFACE 、PUBLIC、PRIVATE</h5></li>
<li><p><input disabled="" type="checkbox"> </p>
<h5 id="cmake-的生成器"><a href="#cmake-的生成器" class="headerlink" title="cmake 的生成器"></a>cmake 的生成器</h5></li>
<li><p><input disabled="" type="checkbox"> 
创建可执行目标的CMake命令是什么？<br>2.创建库目标的CMake命令是什么？<br>\3. 如何指定库是静态链接还是动态链接？<br>\4. 对象库有什么特别之处，它们在哪里派上用场？<br>\5. 如何指定共享库的默认符号可见性？<br>\6. 如何为目标指定编译器选项以及如何查看编译命令？</p>
</li>
<li><p><input disabled="" type="checkbox"> </p>
<h5 id="GoogleTest-cmake和FindGoogleTest-cmake的区别"><a href="#GoogleTest-cmake和FindGoogleTest-cmake的区别" class="headerlink" title="GoogleTest.cmake和FindGoogleTest.cmake的区别"></a>GoogleTest.cmake和FindGoogleTest.cmake的区别</h5></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试相关</title>
    <url>/2022/08/17/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/gdb%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h6 id="core文件定位，使用这些工具和指令排查基本步骤包括："><a href="#core文件定位，使用这些工具和指令排查基本步骤包括：" class="headerlink" title="core文件定位，使用这些工具和指令排查基本步骤包括："></a>core文件定位，使用这些工具和指令排查基本步骤包括：</h6><ul>
<li><p>通过 top 找到内存泄露的进程</p>
</li>
<li><p>通过 pmap 找到内存泄露的地址及范围</p>
</li>
<li><p>通过 gcore 对进程内存进行快照，gcore 产生 coredump 文件</p>
</li>
<li><p>通过 gdb 加载内存信息，gdb 加载 coredump 文件</p>
</li>
<li><p>通过gdb的 dump binary 导出泄露内存的内容，(gdb) dump binary memory result.bin {start_addr} {end_addr}命令 dump 内存</p>
</li>
<li><p>通过 vim 查看内存内容，根据内存中的内容，锁定对应的代码段，进行排查修复，使用 :%!xxd 的方式查看内容</p>
</li>
<li><p>常用命令：</p>
<ul>
<li>top -b -n 1 -H -p 12877</li>
<li>pmap -x -p 12877</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h6 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h6><p>分为两种模式:all-stop模式和no-stop模式.（gdb7.0之前不支持no-stop模式）</p>
<ul>
<li>all-stop：当程序在gdb因某种原因停止时,所有的线程都会停止.一般来说,gdb不能够单步所有线程,因为线程调度室gdb无法控制的(???).无论何时,当gdb停止你的程序时.它都会自动切换到触发断点的那个线程.</li>
<li>no-stop(网络编程常用)：只是当前线程会被停止,而其他线程将会继续运行.此时step,next只对当前线程起作用.</li>
<li>gdb调试多线程常用命令<ul>
<li>info threads : 显示可以调试的所有线程</li>
<li>thread ID : 切换到指定ID的线程</li>
<li>break FileName.cpp:LinuNum thread all：所有线程都在文件FileName.cpp的第LineNum行有断点。</li>
<li>thread apply ID1 ID2 IDN command: 让线程编号是ID1，ID2…等等的线程都执行command命令。</li>
<li>thread apply all command：所有线程都执行command命令。</li>
<li>set scheduler-locking off|on|step： 在调式某一个线程时，其他线程是否执行。在使用step或continue命令调试当前被调试线程的时候，其他线程也是同时执行的，如果我们只想要被调试的线程执行，而其他线程停止等待，那就要锁定要调试的线程，只让他运行。off:不锁定任何线程，默认值。 on:锁定其他线程，只有当前线程执行。</li>
<li>step:在step（单步）时，只有被调试线程运行。</li>
<li>set non-stop on&#x2F;off: 当调式一个线程时，其他线程是否运行。</li>
<li>set pagination on&#x2F;off: 在使用backtrace时，在分页时是否停止。</li>
<li>set target-async on&#x2F;off: 同步和异步。同步，gdb在输出提示符之前等待程序报告一些线程已经终止的信息。而异步的则是直接返回。</li>
<li>show scheduler-locking： 查看当前锁定线程的模式</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>docker了解</title>
    <url>/2022/05/19/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/docker/</url>
    <content><![CDATA[<h3 id="Docker了解"><a href="#Docker了解" class="headerlink" title="Docker了解"></a>Docker了解</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>镜像</strong>（<code>Image</code>）</p>
<p>一堆压缩在一起的静态软件包</p>
<p><strong>容器</strong>（<code>Container</code>）</p>
<p>这堆静态包执行的过程</p>
<p><strong>仓库</strong>（<code>Repository</code>）</p>
<p>镜像的存放地方</p>
<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><h6 id="docker-stop-docker-ps-a-q"><a href="#docker-stop-docker-ps-a-q" class="headerlink" title="docker stop $(docker ps -a -q)"></a>docker stop $(docker ps -a -q)</h6><p>停止所有容器运行</p>
<h6 id="docker-rm-docker-ps-a-q"><a href="#docker-rm-docker-ps-a-q" class="headerlink" title="docker rm $(docker ps -a -q)"></a>docker rm $(docker ps -a -q)</h6><p>删除所有停止运行的容器</p>
<h6 id="docker-ps-a-q"><a href="#docker-ps-a-q" class="headerlink" title="docker ps -a -q"></a><strong>docker ps -a -q</strong></h6><ul>
<li><code>docker ps</code> 列出容器。</li>
<li><code>-a</code> 这个选项用于列出所有容器，包括停止运行的。如果没有这个选项，则默认只列出在运行的容器。</li>
<li><code>-q</code> 这个选项列出容器的数字 ID，而不是容器的所有信息。</li>
</ul>
<h6 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h6><p>删除镜像</p>
<h6 id="docker-commit"><a href="#docker-commit" class="headerlink" title="docker commit"></a>docker commit</h6><p>Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code> 的语法格式为：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</span><br><span class="line">//会记录下所有的改动，可能会导致冗余</span><br></pre></td></tr></table></figure>



<h6 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h6><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> amazonlinux:<span class="number">2.0</span>.<span class="number">20200722.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y epel-releas jq initscripts sudo nc gdb net-tools make vim lsof <span class="built_in">which</span> tar tree              \</span></span><br><span class="line"><span class="language-bash">    procps python3 openssh-clients unzip &amp;&amp; pip3 install requests awscli supervisor pipenv</span></span><br><span class="line">//docker build -f docker_file -t sunketo-redhat:v0.<span class="number">0.1</span> .</span><br></pre></td></tr></table></figure>

<h6 id="docker-push"><a href="#docker-push" class="headerlink" title="docker push"></a>docker push</h6><figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker push yefengdanqing/sunketo-redhat:v0.<span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<p>必须先要docker tag，然后才能带上用户名再进行push</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><span class="line">docker tag sunketo-redhat:v0.<span class="number">0.1</span> yefengdanqing/sunketo-redhat:v0.<span class="number">0.1</span></span><br></pre></td></tr></table></figure>



<figure class="highlight do"><table><tr><td class="code"><pre><span class="line">docker ps #查看运行的docker</span><br><span class="line">docker <span class="keyword">run</span> -t #绑定一个伪终端运行;-i则让容器的标准输入保持打开，可以进行交互;-<span class="keyword">d</span> <span class="keyword">Run</span> container <span class="keyword">in</span> background and <span class="keyword">print</span> container ID,-v绑定一个目录，-w在容器里面的</span><br><span class="line">docker exec 进入一个以backgroud方式运行的容器</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<span id="more"></span>



<p>sudo chmod 666 &#x2F;var&#x2F;run&#x2F;docker.sock</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>一些小的使用技巧</title>
    <url>/2023/04/11/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%82%B9/</url>
    <content><![CDATA[<ol>
<li>终端显示用户和ip等</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IP=$(/sbin/ifconfig eth0|awk &#x27;/inet / &#123;print $2&#125;&#x27;)</span><br><span class="line">export PS1=&quot;\[\e[32;1m\][\u@ali-vg-$IP \W]$\[\e[0m\]&quot;</span><br></pre></td></tr></table></figure>

<p>2. </p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>了解flatbuffer</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E4%BA%86%E8%A7%A3flatbuffer/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://github.com/google/flatbuffers">FlatBuffers</a>是为Google发布的一个跨平台，提供多种语言接口，注重性能和资源使用的序列化类库。目前该类库提供C++、C#、C、GO、Java、JavaScript、PHP、Python语言接口。该序列化库多用于移动端手游数据传输以及特定的对性能要求较高的应用。具有一下特点：</p>
<p>1、对序列化的数据不需要打包和拆包</p>
<p>2、内存和效率速度高，扩展灵活</p>
<p>3、代码依赖较少</p>
<p>4、强类型设计，编译期即可完成类型检查</p>
<p>5、使用简单、可跨平台使用</p>
<span id="more"></span>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通过flact 生成类似pb的.h&#x2F;.cpp文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******</span></span><br><span class="line"><span class="comment">table AdvOfferTable;</span></span><br><span class="line"><span class="comment">******/</span></span><br><span class="line"><span class="comment">//创建指针</span></span><br><span class="line"><span class="keyword">auto</span> builder = std::<span class="built_in">make_shared</span>&lt;flatbuffers::FlatBufferBuilder&gt;();</span><br><span class="line"><span class="keyword">auto</span> &amp;table_builder = *(builder.<span class="built_in">get</span>());</span><br><span class="line"><span class="comment">//中介获取数据，然后通过CreateXXX获得偏移量</span></span><br><span class="line"><span class="keyword">auto</span> offset = <span class="built_in">CreateCreativePackageTable</span>(table_builder, cpId, whDcoId, status, setting, updated, updatedDate);</span><br><span class="line"><span class="comment">//完成序列化</span></span><br><span class="line">builder-&gt;<span class="built_in">Finish</span>(offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化为结构体指针</span></span><br><span class="line"><span class="keyword">auto</span> table = flatbuffers::<span class="built_in">GetRoot</span>&lt;AdvOfferTable&gt;(builder-&gt;<span class="built_in">GetBufferPointer</span>());</span><br><span class="line"><span class="keyword">auto</span> tmp = table-&gt;<span class="built_in">xxx</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>flatbuffers</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>consul初识</title>
    <url>/2022/03/04/%E4%B8%AD%E9%97%B4%E4%BB%B6/consul/consul%E4%BA%86%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>

<p>&#x2F;usr&#x2F;bin&#x2F;consul operator raft list-peer</p>
]]></content>
  </entry>
  <entry>
    <title>ssh免密登录配置</title>
    <url>/2022/08/04/%E5%9F%BA%E7%A1%80/%E5%85%B6%E4%BB%96/%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>出现如下错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Permission denied (publickey,gssapi-keyex,gssapi-with-mic)</span><br></pre></td></tr></table></figure>

<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol>
<li><p>客户端即A端生成RSA公钥和私钥 ssh-keygen</p>
</li>
<li><p>客户端将自己的公钥存放到服务器：在生成了公私钥之后要实现AB两端的交互认证，这两个文件肯定不能只放到A端，当然也需要在B端（服务器端）做一下登记，我们自己（A端）保留自己的私钥，然后把公钥id_rsa.pub存放到B端（一般是在用户根目录下的.ssh&#x2F;目录下</p>
</li>
<li><p>配置sshd服务选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config </span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GSSAPIAuthentication <span class="built_in">yes</span></span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">GSSAPICleanupCredentials no</span></span><br><span class="line">PermitRootLogin no</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">ChallengeResponseAuthentication yes</span><br><span class="line">RSAAuthentication yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/image-20230227141430662.png" alt="image-20230227141430662"></p>
</li>
<li><p>设置权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//用户权限</span><br><span class="line"></span><br><span class="line">    chmod 700 /home/username</span><br><span class="line"></span><br><span class="line">    //.ssh文件夹权限</span><br><span class="line"></span><br><span class="line">    chmod 700 ~/.ssh/</span><br><span class="line"></span><br><span class="line">    // ~/.ssh/authorized_keys 文件权限</span><br><span class="line"></span><br><span class="line">    chmod 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>使用ssh-copy-id进行copy</p>
<p>查看日志<code>tail /var/log/secure -n 100</code></p>
<p>如果通过跳机登录，拷贝客户端机器和跳机的公钥key到最终的目的机器</p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>Linux内存简介</title>
    <url>/2022/02/22/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<ul>
<li><p>Linux内存</p>
</li>
<li><p>查看内存</p>
<p> <img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/free.jpg" alt="free"></p>
</li>
<li><p>字段含义</p>
</li>
<li><p>第一部分Mem行：</p>
<ul>
<li><p>total：内存总数</p>
</li>
<li><p>used：已经使用的内存数</p>
</li>
<li><p>free：空闲的内存数</p>
</li>
<li><p>shared：可用的共享内存</p>
</li>
<li><p>buffers：内存缓冲数</p>
</li>
<li><p>cached：内存缓存数</p>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>第二部分:(-&#x2F;+ buffers&#x2F;cache)</p>
</li>
<li><p>used:除去被用作buffers和cache内存后已用的内存</p>
</li>
<li><p>free：用作buffers和cache的内存加上Mem部分空闲的内存数</p>
</li>
<li><p>buffers：是缓冲；相当于是</p>
</li>
<li><p>cache：缓存；</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/free2.jpg" alt="free2"></p>
</li>
</ul>
<p>三、buffers和cached解释</p>
<ul>
<li><p><strong>缓存（cached）</strong>是把读取过的数据保存起来，重新读取时若命中（找到需要的数据）就不要去读硬盘了，若没有命中就读硬盘。其中的数据会根据读取频率进行组织，把最频繁读取的内容放在最容易找到的位置，把不再读的内容不断往后排，直至从中删除。</p>
</li>
<li><p><strong>缓冲（buffers）</strong>是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。linux有一个守护进程定期清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。举个例子吧：我这里有一个ext2的U盘，我往里面cp一个3M的MP3，但U盘的灯没有跳动，过了一会儿（或者手动输入sync）U盘的灯就跳动起来了。卸载设备时会清空缓冲，所以有些时候卸载一个设备时要等上几秒钟。</p>
</li>
<li><p>修改&#x2F;etc&#x2F;sysctl.conf中的vm.swappiness右边的数字可以在下次开机时调节swap使用策略。该数字范围是0～100，数字越大越倾向于使用swap。默认为60，可以改一下试试。–两者都是RAM中的数据。</p>
</li>
<li><p><strong>两者都是RAM中的数据，简单来说，buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的。</strong><br> buffer是由各种进程分配的，被用在如输入队列等方面。一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存。<br> cache经常被用在磁盘的I&#x2F;O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提高系统性能。</p>
</li>
<li><p><strong>Cache：缓冲区，高速缓存，是位于CPU与主内存间的一种容量较小但速度很高的存储器。</strong>由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用,这样就减少了CPU的等待时间,提高了系统的效率。Cache又分为一级Cache(L1 Cache)和二级Cache(L2 Cache)，L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上,现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。它是根据程序的局部性原理而设计的，就是cpu执行的指令和访问的数据往往在集中的某一块，所以把这块内容放入cache后，cpu就不用在访问内存了，这就提高了访问速度。当然若cache中没有cpu所需要的内容，还是要访问内存的。<strong>从内存读取与磁盘读取角度考虑，cache可以理解为操作系统为了更高的读取效率，更多的使用内存来缓存可能被再次访问的数据。</strong></p>
</li>
<li><p>Cache并不是缓存文件的，而是缓存块的(块是I&#x2F;O读写最小的单元)；Cache一般会用在I&#x2F;O请求上，如果多个进程要访问某个文件，可以把此文件读入Cache中，这样下一个进程获取CPU控制权并访问此文件直接从Cache读取，提高系统性能。</p>
</li>
<li><p><strong>Buffer：缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域</strong>。通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可以干其他的事情。</p>
</li>
<li><p>Buffer：一般是用在写入磁盘的，例如：某个进程要求多个字段被读入，当所有要求的字段被读入之前已经读入的字段会先放到buffer中。Buffer是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。linux有一个守护进程定期清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。</p>
</li>
<li><p>cache是高速缓存，用于CPU和内存之间的缓冲；<br>buffer是I&#x2F;O缓存，用于内存和硬盘的缓冲；</p>
</li>
<li><p>cache最初用于cpu cache，主要原因是cpu 与memory，由于cpu快，memory跟不上,且有些值使用次数多，所以放入cache中，主要目的是，重复使用，并且一级\二级物理cache速度快，<br>buffer主要用于disk与 memory，主要是保护硬盘或减少网络传输的次数（内存数据表现dataSet）．当然也可以提高速度（不会立即写入硬盘或直接从硬盘中读出的数据马上显示），重复使用，最初最主要的目的是保护disk,</p>
</li>
<li><p>Free中的buffer和cache：（它们都是占用内存）：<br>buffer : 作为buffer cache的内存，是块设备的读写缓冲区<br>cache: 作为page cache的内存, 文件系统的cache</p>
</li>
<li><p>如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO bi会非常小。</p>
</li>
<li><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>下面通过一些简单通俗的例子来说明下Cache和Buffer缓存之间的区别：</p>
</li>
<li><p><strong>1）Cache缓存</strong></p>
</li>
<li><p>假设某地发生了自然灾害（比如地震），居民缺衣少食，于是派救火车去给若干个居民点送水。救火车到达第一个居民点，开闸放水，老百姓就拿着盆盆罐罐来接水。假如说救火车在一个居民点停留100分钟放完了水，然后重新储水花半个小时，再开往下一个居民点。这样一个白天来来来回回的，也就是4-5个居民点。</p>
</li>
<li><p>但我们想想，救火车是何等存在，如果把水龙头完全打开，其强大的水压能轻易冲上10层楼以上， 10分钟就可以把水全部放完。但因为居民是拿盆罐接水，100%打开水龙头那就是给人洗澡了，所以只能打开一小部分（比如10%的流量）。但这样就降低了放水的效率（只有原来的10%了），10分钟变100分钟。</p>
</li>
<li><p>那么，我们是否能改进这个放水的过程，让救火车以最高效率放完水、尽快赶往下一个居民点呢？<br>方法就是：在居民点建蓄水池。<br>救火车把水放到蓄水池里，因为是以100%的效率放水，10分钟结束然后走人。居民再从蓄水池里一点一点的接水。</p>
</li>
<li><p>我们分析一下这个例子，就可以知道Cache的含义了。<br>救火车要给居民送水，居民要从救火车接水，就是说居民和救火车之间有交互，有联系。<br>但救火车是”高速设备”，居民是”低速设备”，低速的居民跟不上高速的救火车，所以救火车被迫降低了放水速度以适应居民。<br>为了避免这种情况，在救火车和居民之间多了一层”蓄水池（也就是Cache）”，它一方面以100%的高效和救火车打交道，另一方面以10%的低效和居民打交道，这就解放了救火车，让其以最高的效率运行，而不被低速的居民拖后腿，于是救火车只需要在一个居民点停留10分钟就可以了。<br>所以说，蓄水池是”活雷锋”，把高效留给别人，把低效留给自己。把10分钟留给救火车，把100分钟留给自己。</p>
</li>
<li><p>从以上例子可以看出，所谓Cache，就是”为了弥补高速设备和低速设备之间的矛盾”而设立的一个中间层。因为在现实里经常出现高速设备要和低速设备打交道，结果被低速设备拖后腿的情况。Cache的存在是为了解决什么问题？速度太慢了，要<strong>加快速度！</strong></p>
</li>
<li><p>以PC为例。CPU速度很快，但CPU执行的指令是从内存取出的，计算的结果也要写回内存，但内存的响应速度跟不上CPU。CPU跟内存说：你把某某地址的指令发给我。内存听到了，但因为速度慢，迟迟不见指令返回，这段时间，CPU只能无所事事的等待了。这样一来，再快的CPU也发挥不了效率。<br>怎么办呢？在CPU和内存之间加一块”蓄水池”，也就是Cache（片上缓存），这个Cache速度比内存快，从Cache取指令不需要等待。当CPU要读内存的指令的时候先读Cache再读内存，但一开始Cache是空着的，只能从内存取，这时候的确是很慢，CPU需要等待。但从内存取回的不仅仅是CPU所需要的指令，还有其它的、当前不需要的指令，然后把这些指令存在Cache里备用。CPU再取指令的时候还是先读Cache，看看里面有没有所需指令，如果碰巧有就直接从Cache取，不用等待即可返回（命中），这就解放了CPU，提高了效率。（当然不会是100%命中，因为Cache的容量比内存小）</p>
</li>
<li><p><strong>2）Buffer缓存</strong></p>
</li>
<li><p>比如说吐鲁番的葡萄熟了，要用大卡车装葡萄运出去卖果园的姑娘采摘葡萄，当然不是前手把葡萄摘下来,后手就放到卡车上，而是需要一个中间过程”箩筐”：摘葡萄→放到箩筐里→把箩筐里的葡萄倒入卡车。也就是说，虽然最终目的是”把葡萄倒入卡车”，但中间必须要经过”箩筐”的转手，这里的箩筐就是Buffer。是”暂时存放物品的空间”。<br>注意2个关键词：暂时，空间<br>再换句话说，为了完成最终目标：把葡萄放入卡车的空间，需要暂时把葡萄放入箩筐的空间。</p>
</li>
<li><p>以BT为例，BT下载需要长时间的挂机，电脑就有可能24小时连轴转，但BT下载的数据是碎片化的，体现在硬盘写入上也是碎片化的，因为硬盘是机械寻址器件，这种碎片化的写入会造成硬盘长时间高负荷的机械运动，造成硬盘过早老化损坏，当年有大量的硬盘因为BT下载而损坏。于是新出的BT软件在内存里开辟了Buffer，数据暂时写入Buffer，攒到一定的大小（比如512M）再一次性写入硬盘，这种”化零为整”的写入方式大大降低了硬盘的负荷。这就是：为了完成最终目标：把数据写入硬盘空间，需要暂时写入Buffer的空间。</p>
</li>
<li><p><strong>3）二者之间的区别总结</strong></p>
</li>
<li><p>Cache和Buffer的相同点：都是2个层面之间的中间层，都是内存。<br>Cache和Buffer的不同点：Cache解决的是时间问题，Buffer解决的是空间问题。<br>为了提高速度，引入了Cache这个中间层。<br>为了给信息找到一个暂存空间，引入了Buffer这个中间层。<br>为了解决2个不同维度的问题（时间、空间），恰巧取了同一种解决方法：加入一个中间层，先把数据写到中间层上，然后再写入目标。<br>这个中间层就是内存“RAM”，既然是存储器就有2个参数：写入的速度有多块（速度），能装多少东西（容量）<br>Cache利用的是RAM提供的高读写速度，Buffer利用的是RAM提供的存储容量（空间）。</p>
</li>
<li><p>简言之：<br>\1. Buffer（缓冲区）是系统两端处理速度平衡（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I&#x2F;O的影响，起到流量整形的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生&#x2F;消耗时的突然变化。<br>\2. Cache（缓存）则是系统两端处理速度不匹配时的一种折衷策略。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。<br>\3. 假定以后存储器访问变得跟CPU做计算一样快，cache就可以消失，但是buffer依然存在。比如从网络上下载东西，瞬时速率可能会有较大变化，但从长期来看却是稳定的，这样就能通过引入一个buffer使得OS接收数据的速率更稳定，进一步减少对磁盘的伤害。</p>
</li>
<li></li>
<li><p>C++内存</p>
</li>
<li><p>参考：<a href="https://www.cnblogs.com/M18-BlankBox/p/5326484.html">https://www.cnblogs.com/M18-BlankBox/p/5326484.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux和c++多线程</title>
    <url>/2022/02/22/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%92%8Cc++%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h6 id="Linux多线程"><a href="#Linux多线程" class="headerlink" title="Linux多线程"></a>Linux多线程</h6><ul>
<li><p>定义</p>
<ul>
<li>线程的join（联合的）和detch（分离的）；1）当使用join()函数时，主调线程(main函数里有一个主调线程)阻塞，等待被调线程终止，然后主调线程回收被调线程资源，并继续运行；上面这段话的意思就是，使用join(),线程运行完,main函数才能结束。（2）当使用detach()函数时，主调线程继续运行，被调线程驻留后台运行，主调线程无法再取得该被调线程的控制权。当主调线程结束时，由运行时库负责清理与被调线程相关的资源。上面这段话的意思就是，使用detach(),main函数不用等待线程结束才能结束。有时候线程还没运行完，main函数就已经结束了。</li>
<li>xxx</li>
</ul>
</li>
<li><p>自旋锁</p>
<ul>
<li>定义：自旋锁的目的是将一个并行化的数据串行化，自旋锁的循环指令标识cpu忙等待，在等待的内核路径上无事可做的时候，其也会在cpu上运行（浪费cpu的时间），【volatile标识当前修改的值立马更新到内存中】自旋锁是为了保证临界区代码</li>
</ul>
<span id="more"></span>

<ul>
<li><p>spin_lock相当于get_and_set判断是否获取并设置成功，</p>
</li>
<li><p>这里有两个常用的方法可以使用：<code>TAS（test and set）</code>和<code>CAS （compare and swap）</code>。</p>
<ul>
<li><p>TAS：一个TAS指令包括两个子步骤，把给定的内存地址设置为1，然后返回之前的旧值。</p>
</li>
<li><p><code>CAS</code>：CAS指令需要三个参数，一个内存位置(V)、一个期望旧值(A)、一个新值(B)。过程如下：</p>
<p>a. 比较内存V的值是否与A相等？<br>b. 如果相等，则用新值B替换内存位置V的旧值<br>c. 如果不相等，不做任何操作。<br>d. 无论哪个情况，CAS都会把内存V原来的值返回。</p>
<p>TAS是直接写操作，CAS是先比较，满足条件后再写。而<code>写</code>是一个相对耗时的操作，因此在高并发、频繁使用锁的场景，CAS性能会更好。</p>
</li>
</ul>
<p>很多语言都提供了封装后的TAS和CAS调用方法。</p>
<ol>
<li>以C++ 11为例，<code>atomic</code>标准库提供了相关方法：<a href="https://en.cppreference.com/w/c/atomic/atomic_flag_test_and_set">std::atomic_flag::test_and_set</a>和<a href="http://www.cplusplus.com/reference/atomic/atomic/compare_exchange_strong/">std::atomic::compare_exchange_strong</a></li>
<li>GCC编译器也内置了相关方法：<code>__atomic_test_and_set</code>和<code>__atomic_compare_exchange_n</code>.</li>
<li>Java也提供了例如<code>java.util.concurrent.atomic.AtomicReference.compareAndSet</code>等方法。</li>
</ol>
</li>
<li><p>api：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="built_in">spin_lock_init</span>(<span class="type">spinlock_t</span> *lock);</span><br><span class="line"><span class="built_in">spin_lock</span>(<span class="type">spinlock_t</span> *lock);</span><br><span class="line"><span class="built_in">spin_unlock</span>(<span class="type">spinlock_t</span> *lock);</span><br><span class="line"><span class="built_in">spin_trylock</span>(<span class="type">spinlock_t</span> *lock);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：</p>
</li>
<li><p>注意点：由于自旋锁，一直会去申请</p>
</li>
</ul>
</li>
<li><p>互斥量</p>
<ul>
<li>定义：主要用来互斥访问共享资源，当一个线程拿到互斥锁，其他线程再去拿就会陷入阻塞等待状态，只有这个互斥锁释放，才会唤醒其他线程，那个线程获得互斥锁取决于线程的优先级和cpu的调度算法,一般是先等待的先获得；互斥量的状态，0、1或者其他负数，初始化为1【&#x2F;* 1: unlocked, 0: locked, negative: locked, possible waiters *&#x2F;】，其中有个进程（线程队列等待中）。</li>
<li>api:init、lock、unlock、trylock、destory、</li>
<li>使用：互斥锁是一种建议锁，如果进程中有多线程访问，必须按照加锁、处理、解锁的步骤，不然还是会导致数据错乱。当一个线程lock了互斥量，当另外一个线程去lock的时候，这个线程会阻塞，让出cpu；互斥量的使用流程应该是：线程占用互斥量，然后访问共享资源，最后释放互斥量。</li>
<li>优缺点：所有的线程都去锁这个互斥量（锁），</li>
<li>注意点：互斥锁不能进行递归锁定或者解锁；一个互斥锁对象必须通过其API初始化，而不能使用memset或复制初始化；一个任务在持有互斥锁的时候是不能结束的；互斥锁所使用的内存区域是不能被释放的。使用中的互斥锁是不能被重新初始化的。并且互斥锁不能用于中断上下文。但是互斥锁比当前的内核信号量选项更快，并且更加紧凑，</li>
</ul>
</li>
<li><p>条件变量</p>
<ul>
<li><p>定义：利用线程间共享的全局变量进行同步的一种机制；包括两个动作：等待条件变量成立的而被挂起（阻塞？）；条件变量成立后唤醒（发送一个信号）其他线程；用来等待;</p>
</li>
<li><p>api:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">pthread_cond_wait</span>(<span class="type">pthread_cond_t</span>* cond, <span class="type">pthread_mutex_t</span>* mutex);</span><br><span class="line"><span class="built_in">pthread_cond_timedwait</span>(<span class="type">pthread_cond_t</span> *__restrict __cond,</span><br><span class="line">                                   <span class="type">pthread_mutex_t</span> *__restrict __mutex,</span><br><span class="line">                                   __const <span class="keyword">struct</span> timespec *__restrict __abstime);</span><br><span class="line"></span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(<span class="type">pthread_cond_t</span>* cond);</span><br><span class="line"><span class="built_in">pthread_cond_broadcast</span>(<span class="type">pthread_cond_t</span>* cond);</span><br><span class="line"><span class="built_in">pthread_cond_destory</span>(<span class="type">pthread_cond_t</span>* cond);</span><br><span class="line"><span class="built_in">pthread_cond_init</span>(<span class="type">pthread_cond_t</span>* cond, <span class="type">void</span>* ptr);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：在wait的时候必须用while循环（不用if)；在signal的时候必须加互斥量；wait 函数会先将线程放在线程等待队列，然后将互斥量（互斥锁）解锁。</p>
</li>
<li><p>注意点：条件变量的使用必须配合互斥量；唤醒丢失;惊群现象(只给一个线程（优先级和最老的）发，不给其他线程发）；在生产端加互斥量是为了保证原子性，变量的改变和唤醒是一个原子操作；</p>
</li>
</ul>
</li>
<li><p>信号量</p>
<ul>
<li><p>定义：临界区是更新数据的代码需要独占式的执行；二进制信号量和通用信号量；P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行；V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.</p>
</li>
<li><p>api：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key,<span class="type">int</span> num_sems,<span class="type">int</span> sem_flags)</span>；</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> sem_id,<span class="type">int</span> sem_num,<span class="type">int</span> command,[<span class="keyword">union</span> semun sem_union])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> sem_id,<span class="keyword">struct</span> sembuf *sem_opa,<span class="type">size_t</span> num_sem_ops)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：信号量是一种特殊的变量，访问具有原子性。<br>只允许对它进行两个操作：<br>1)等待信号量<br>当信号量值为0时，程序等待；当信号量值大于0时，信号量减1，程序继续运行。<br>2)发送信号量<br>将信号量值加1。</p>
</li>
<li><p>注意点：信号量是不知道属主的，互斥量是知道的</p>
</li>
</ul>
</li>
<li><p>读写锁</p>
<ul>
<li><p>定义：读模式下加锁、写模式下加锁、不加锁</p>
</li>
<li><p>api：pthread_rwlock_init；pthread_rwlock_destory;</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 初始化读写锁属性对象 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_init</span> <span class="params">(<span class="type">pthread_rwlockattr_t</span> *__attr)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 销毁读写锁属性对象 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_destroy</span> <span class="params">(<span class="type">pthread_rwlockattr_t</span> *__attr)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 获取读写锁属性对象在进程间共享与否的标识*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_getpshared</span> <span class="params">(__const <span class="type">pthread_rwlockattr_t</span> * __restrict __attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">int</span> *__restrict __pshared)</span></span>;</span><br><span class="line"><span class="comment">/* 设置读写锁属性对象，标识在进程间共享与否  */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlockattr_setpshared</span> <span class="params">(<span class="type">pthread_rwlockattr_t</span> *__attr, <span class="type">int</span> __pshared)</span></span>;</span><br><span class="line"> <span class="comment">/*返回值：成功返回0，否则返回错误代码*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 读模式下加锁  */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 非阻塞的读模式下加锁  */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_tryrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="comment">/*  限时等待的读模式加锁 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_timedrdlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       __const <span class="keyword">struct</span> timespec *__restrict __abstime)</span></span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 写模式下加锁  */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 非阻塞的写模式下加锁 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_trywrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __USE_XOPEN2K</span></span><br><span class="line"><span class="comment">/* 限时等待的写模式加锁 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_timedwrlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       __const <span class="keyword">struct</span> timespec *__restrict __abstime)</span></span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 解锁 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="type">pthread_rwlock_t</span> *__rwlock)</span></span>;</span><br><span class="line"> <span class="comment">/*返回值：成功返回0，否则返回错误代码*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用：只要没有写模式下的加锁，任意线程都可以进行读模式下的加锁；只有读写锁处于不加锁状态时，才能进行写模式下的加锁；</p>
</li>
<li><p>注意点</p>
</li>
</ul>
</li>
<li><p>死锁</p>
<ul>
<li>定义</li>
<li>解决方案</li>
<li>其他</li>
</ul>
</li>
<li><p>无锁编程</p>
<ul>
<li><p>cas: compare and swap (一个旧值和一个新值，旧值相当则进行操作，不想当不操作）</p>
</li>
<li><p>优点：</p>
</li>
<li><ol>
<li>没有提升性能</li>
<li>避免死锁</li>
<li></li>
</ol>
</li>
</ul>
</li>
<li><p>样例</p>
<ul>
<li>读者写者问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf = <span class="number">0</span>;  <span class="comment">//buf全局变量就是临界资源。</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">reader</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*if(pthread_rwlock_tryrdlock(&amp;rwlock)) &#123;</span></span><br><span class="line"><span class="comment">            std::cout &lt;&lt; &quot;continue try read lcok&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            std::cout &lt;&lt; &quot;reader do othrer thing!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            continue;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            buf++;</span></span><br><span class="line"><span class="comment">            std::cout &lt;&lt; &quot;read buf:&quot; &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            pthread_rwlock_unlock(&amp;rwlock);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;read buf:&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">writer</span><span class="params">(<span class="type">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*if (pthread_rwlock_trywrlock(&amp;rwlock)) &#123;</span></span><br><span class="line"><span class="comment">            std::cout &lt;&lt; &quot;continue try read lcok&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            std::cout &lt;&lt; &quot;reader do othrer thing!&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            continue;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            buf++;</span></span><br><span class="line"><span class="comment">            std::cout &lt;&lt; &quot;write buf:&quot; &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">            pthread_rwlock_unlock(&amp;rwlock);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);</span><br><span class="line">        buf++;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;write buf:&quot;</span> &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">pthread_rwlock_unlock</span>(&amp;rwlock);</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;rwlock,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="type">pthread_t</span> r[<span class="number">5</span>],w;</span><br><span class="line">     <span class="built_in">pthread_create</span>(&amp;r[<span class="number">0</span>],<span class="literal">NULL</span>,reader,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">pthread_create</span>(&amp;r[<span class="number">1</span>],<span class="literal">NULL</span>,reader,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">pthread_create</span>(&amp;r[<span class="number">2</span>],<span class="literal">NULL</span>,reader,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">pthread_create</span>(&amp;r[<span class="number">3</span>],<span class="literal">NULL</span>,reader,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">pthread_create</span>(&amp;r[<span class="number">4</span>],<span class="literal">NULL</span>,reader,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">pthread_create</span>(&amp;w,<span class="literal">NULL</span>,writer,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">pthread_join</span>(r[i],<span class="literal">NULL</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">pthread_join</span>(w,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者消费者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond1;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; product;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">produce</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line">        <span class="keyword">while</span>(product.<span class="built_in">size</span>() &gt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond1, &amp;mutex1);</span><br><span class="line">        &#125;</span><br><span class="line">        product.<span class="built_in">push</span>(i);</span><br><span class="line">        i++;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;produce:&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line"><span class="comment">//pthread_cnod_singal(&amp;cond, &amp;mutex);</span></span><br><span class="line">        <span class="keyword">if</span> (product.<span class="built_in">size</span>() &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consume</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line">        <span class="keyword">while</span>(product.<span class="built_in">size</span>() &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*if(product.empty()) &#123;</span></span><br><span class="line"><span class="comment">            pthread_cond_wait(&amp;cond, &amp;mutex);</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;consume:&quot;</span>&lt;&lt;product.<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">        product.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (product.<span class="built_in">size</span>() &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="built_in">pthread_cond_signal</span>(&amp;cond1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;cond1, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid1, <span class="literal">NULL</span>, consume, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;tid2, <span class="literal">NULL</span>, produce, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="type">void</span> *retVal;</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid1, &amp;retVal);</span><br><span class="line">    <span class="built_in">pthread_join</span>(tid2, &amp;retVal);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="c-11-多线程"><a href="#c-11-多线程" class="headerlink" title="c++11 多线程"></a>c++11 多线程</h5><h6 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h6><p>在传入线程函数的参数的时候，我们可以通过std::ref()和move来解决引用没有传递的情况；</p>
</li>
<li><p>Lock(unique_lock和guard_lock)</p>
<ul>
<li><p>unique_lock和guard_lock都是通过构造函数加锁，析构函数解锁</p>
</li>
<li><p>unique_lock比guard_lock大一点，占用的空间多并且慢一点是因为要维护一个状态（locked,unlocked）</p>
</li>
<li><p>unique_lock通过构造不同的构造函数来实现对mutex的所有权，具体看相关的api；unique_lock可以进行移动</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> K_ITEMS_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> K_ITEMS_MAX = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ItemRepository</span> &#123;</span><br><span class="line">    <span class="type">int</span> items[K_ITEMS_SIZE];</span><br><span class="line">    std::mutex mutex;</span><br><span class="line">    std::condition_variable not_empty;</span><br><span class="line">    std::condition_variable full;</span><br><span class="line">    <span class="type">int</span> consumer_pos;</span><br><span class="line">    <span class="type">int</span> producer_pos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce_items</span><span class="params">(ItemRepository* ir, <span class="type">int</span> item)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(ir-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="comment">//if() 和while()的区别</span></span><br><span class="line">    <span class="keyword">while</span> (((ir-&gt;producer_pos + <span class="number">1</span>) % K_ITEMS_SIZE) == ir-&gt;consumer_pos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producer is waiting for an empty slot...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        ir-&gt;full.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Producer item:&quot;</span> &lt;&lt; item &lt;&lt; <span class="string">&quot;, producer pos:&quot;</span> &lt;&lt; ir-&gt;producer_pos &lt;&lt; std::endl;</span><br><span class="line">    ir-&gt;items[ir-&gt;producer_pos++] = item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ir-&gt;producer_pos == K_ITEMS_SIZE) &#123;</span><br><span class="line">        ir-&gt;producer_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ir-&gt;not_empty.<span class="built_in">notify_all</span>();</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_items</span><span class="params">(ItemRepository* ir)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(ir-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (ir-&gt;producer_pos == ir-&gt;consumer_pos) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Producer is waiting for an empty slot...\n&quot;</span>;</span><br><span class="line">        ir-&gt;not_empty.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;consumer item:&quot;</span> &lt;&lt; ir-&gt;items[ir-&gt;consumer_pos] &lt;&lt; <span class="string">&quot;, consumer pos:&quot;</span> &lt;&lt; ir-&gt;consumer_pos++ &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span>(ir-&gt;consumer_pos == K_ITEMS_SIZE) &#123;</span><br><span class="line">        ir-&gt;consumer_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ir-&gt;full.<span class="built_in">notify_one</span>();</span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ItemRepository gItemRepository;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; K_ITEMS_MAX; ++i) &#123;</span><br><span class="line">        <span class="built_in">produce_items</span>(&amp;gItemRepository, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">consume_items</span>(&amp;gItemRepository);</span><br><span class="line">        <span class="keyword">if</span> (cnt++ == K_ITEMS_MAX) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;exit thread&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gItemRepository.consumer_pos = <span class="number">0</span>;</span><br><span class="line">    gItemRepository.producer_pos = <span class="number">0</span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">consumer</span><span class="params">(consume)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">produce</span><span class="params">(producer)</span></span>;</span><br><span class="line"></span><br><span class="line">    consumer.<span class="built_in">join</span>();</span><br><span class="line">    produce.<span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h6 id="无锁队列"><a href="#无锁队列" class="headerlink" title="无锁队列"></a>无锁队列</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line">type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)</span><br><span class="line">gcc支持的原子操作，c++<span class="number">1</span>的atomic也支持一些原子操作</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LockFreeListNode</span> &#123;</span><br><span class="line">    T val;</span><br><span class="line">	LockFreeListNode* tail;</span><br><span class="line">    LockFreeListNode* head;</span><br><span class="line">    LockFreeListNode* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>入队</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(LockFreeListNode* q, T data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> node = <span class="keyword">new</span> <span class="built_in">LockFreeListNode</span>(data);</span><br><span class="line">    <span class="keyword">auto</span> tail = q-&gt;tail;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        tail = q-&gt;tail;</span><br><span class="line">        <span class="keyword">auto</span> next = tail-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (tail != q-&gt;tail) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//说明有其他线程已经加了尾结点，然后异常退出，需要其他线程的这个地方往后移动</span></span><br><span class="line">            <span class="built_in">CAS</span>(q-&gt;tail, tail, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">CAS</span>(tail, next, node) == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里可能异常退出，别的线程也能保证</span></span><br><span class="line">    <span class="built_in">CAS</span>(q-&gt;tail, tail, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出队</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template &lt;class T&gt;</span><br><span class="line">T pop(LockFreeListNode* q) &#123;</span><br><span class="line">    T value;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        auto head = q-&gt;head;</span><br><span class="line">        auto tail = q-&gt;tail;</span><br><span class="line">        auto t_next = head-&gt;next;</span><br><span class="line">        //已经被别的线程取走</span><br><span class="line">        if ( head != q-&gt;head) continue;</span><br><span class="line">        //整个队列为空</span><br><span class="line">        if (head == tail &amp;&amp; t_next == nullptr) &#123;</span><br><span class="line">            return EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        //tail是在head的后面,为啥</span><br><span class="line">        if (head == tail &amp;&amp; t_next == nullptr) &#123;</span><br><span class="line">            CAS(q-&gt;tail, tail, next);</span><br><span class="line">        &#125;</span><br><span class="line">        if (CAS(q-&gt;head, head, t_next) == true) &#123;</span><br><span class="line">            value = t_next-&gt;val;</span><br><span class="line">            break;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delete pre_head;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓ABA（<a href="https://en.wikipedia.org/wiki/ABA_problem">见维基百科的ABA词条</a>），问题基本是这个样子：</p>
<ol>
<li>进程P1在共享变量中读到值为A</li>
<li>P1被抢占了，进程P2执行</li>
<li>P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。</li>
<li>P1回来看到共享变量里的值没有被改变，于是继续执行。</li>
</ol>
<p>虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。<strong>ABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的值。很明显，值是很容易又变成原样的。</strong></p>
<h4 id="解决ABA的问题"><a href="#解决ABA的问题" class="headerlink" title="解决ABA的问题"></a>解决ABA的问题</h4><p>当然，我们这个队列的问题就是不想让那个内存重用，这样明确的业务问题比较好解决，这么一个方法——<strong>使用结点内存引用计数refcnt</strong>！</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux加载程序过程</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>计算机领域的任何问题都可以增加一个间接的中间层来解决</p>
<ul>
<li><p>虚拟内存</p>
<ul>
<li>物理地址空间不隔离的</li>
<li>内存利用率较低</li>
<li>程序运行的地址空间不确定</li>
<li>通过cpu的mmu进行页内存映射</li>
</ul>
</li>
<li><p>线程共享的内容</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/image-20220323143913994.png" alt="image-20220323143913994"></p>
</li>
</ul>
<h6 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h6><p>程序源代码编译后的机器指令经常被放在代码段（code section）里，叫”.code” 或者”.text”;全局变量和静态变量都在数据段，数据段的一般名字叫”.data”;</p>
<p>.data：保存初始化的全局变量和局部静态变量</p>
<p>bss：未初始化的全局变量和局部静态变量存放的地方；其实这些数据也可以放在data段；由于都是0没有必要放。程序运行的时候他们的确是占内存空间的，并且可执行文件必须记录所有未初始化的全局变量和局部静态变量的大小总和，所以bss段只是为变量预留位置而已，在文件中并不占空间；</p>
<span id="more"></span>

<p>总体来说，程序源代码被编译后主要分成两段：程序指令和程序数据。代码段是程序指令，数据段和bss段属于程序数据。</p>
<p>分开的理由：</p>
<ul>
<li>程序指令只是需要用来读；而数据是用来可读可写的</li>
<li>cpu可能数据缓存和指令缓存（cache），分开后可以提高命中率</li>
<li>有多个程序的进程的时候，只需要一份程序指令就行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/image-20220323172822696.png" alt="image-20220323172822696"></p>
<h5 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h5><p>可执行文件：打包指令和数据的文件</p>
<p>程序在运行的时候有局部性原理，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常见的数据存放在磁盘里面，这就是动态载入</p>
<h6 id="页映射"><a href="#页映射" class="headerlink" title="页映射"></a>页映射</h6><p><img src="/C:/Users/sunketo/AppData/Roaming/Typora/typora-user-images/image-20220327170055478.png" alt="image-20220327170055478"></p>
<h6 id="进程的建立"><a href="#进程的建立" class="headerlink" title="进程的建立"></a>进程的建立</h6><ul>
<li>步骤<ol>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系</li>
<li>将cpu的指令寄存器设置成可执行文件的入口地址，启动运行</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>cpu学习</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/cpu/</url>
    <content><![CDATA[<span id="more"></span>

<h6 id="cache-line"><a href="#cache-line" class="headerlink" title="cache line"></a>cache line</h6><p>主存和cache同步数据的最小单位，一般是64字节，内存中的区域都会按照这个大小进行局部性原理的读；</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><hr>
<p><a href="https://zhuanlan.zhihu.com/p/522038503?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=591022433859932160&amp;wechatShare=1&amp;s_r=0">https://zhuanlan.zhihu.com/p/522038503?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=591022433859932160&amp;wechatShare=1&amp;s_r=0</a></p>
]]></content>
  </entry>
  <entry>
    <title>c++程序执行之内存</title>
    <url>/2022/02/18/%E5%9F%BA%E7%A1%80/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/c++%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h6 id="main函数之前和之后"><a href="#main函数之前和之后" class="headerlink" title="main函数之前和之后"></a>main函数之前和之后</h6><ul>
<li>分配空间</li>
<li>初始化静态和全局变量</li>
<li>加载配置参数</li>
<li>之后可以析构回调函数</li>
<li>注册一个main之后的回调函数atexit(func)</li>
<li>可以通过 <strong>attribute</strong> 关键字，声明 <strong>constructor</strong> 和 <strong>destructor</strong> 来实现</li>
</ul>
<span id="more"></span>

<h6 id="malloc实现"><a href="#malloc实现" class="headerlink" title="malloc实现"></a>malloc实现</h6><ul>
<li>当申请小内存（小于128K）的时候，malloc使用sbrk分配内存；当申请大内存时，使用mmap函数申请内存；但是这只是分配了虚拟内存，还没有映射到物理内存，当访问申请的内存时，才会因为缺页异常，内核分配物理内存</li>
<li>new实现的原理<ul>
<li>底层调用malloc：当大于128K时，用mmap在堆和栈的虚拟内存中找一块空间分配；否则调用brk在堆上有高到低的分配；</li>
<li>对比malloc：对于malloc分配失败需要用remalloc</li>
<li>stl 设计当大于128B的时候用maclloc，否则用stl的内存池；<br>new是在自由存储区，而malloc是堆分配</li>
</ul>
</li>
</ul>
<h6 id="c-源码编译"><a href="#c-源码编译" class="headerlink" title="c++源码编译"></a>c++源码编译</h6><p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/64022.jpg" alt="64022"></p>
<h6 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h6><ul>
<li><p>单个继承的话，每个类对应一个虚函数表，子类覆盖子类的虚函数</p>
</li>
<li><p>多继承，一个对象有多个虚函数表指针，指向多张虚函数表，对于当前类新的虚函数，会增加到第一个虚函数指针对应的虚函数表里面。并且最后一个虚函数表会有一个“0”的标记，标识后面没有了虚函数。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/virtual.jpg" alt="virtual"></p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/virtual-func.jpg" alt="virtual-func"></p>
<p><a href="https://www.cnblogs.com/malecrab/p/5573368.html">https://www.cnblogs.com/malecrab/p/5573368.html</a></p>
<p>【<a href="https://blog.csdn.net/qq_36359022/article/details/81870219%E3%80%91%E3%80%90-fdump-class-hierarchy%E6%89%93%E5%8D%B0%E8%99%9A%E8%A1%A8%E3%80%91">https://blog.csdn.net/qq_36359022/article/details/81870219】【-fdump-class-hierarchy打印虚表】</a></p>
<h6 id="c-执行的过程"><a href="#c-执行的过程" class="headerlink" title="c++执行的过程"></a>c++执行的过程</h6>]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/epoll%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>多路复用：一个进程处理多个网络socket，一个socket有哪些信息；</p>
<h6 id="边缘触发和水平触发"><a href="#边缘触发和水平触发" class="headerlink" title="边缘触发和水平触发"></a>边缘触发和水平触发</h6><p>边缘触发和水平触发：状态的变化；边缘触发就是对一个socket 在缓存区中有数据的时候，只触发一次；水平触发就是会一直不断的触发；</p>
<h6 id="水平触发"><a href="#水平触发" class="headerlink" title="水平触发"></a>水平触发</h6><ol>
<li>socket接收缓冲区不为空 有数据可读 读事件一直触发</li>
<li>socket发送缓冲区不满 可以继续写入数据 写事件一直触发<br> 备注：符合思维习惯，epoll_wait返回的事件就是socket的状态</li>
</ol>
<h6 id="边缘触发"><a href="#边缘触发" class="headerlink" title="边缘触发"></a>边缘触发</h6><ol>
<li>socket的接收缓冲区状态变化时触发读事件，即空的接收缓冲区刚接收到数据时触发读事件</li>
<li>socket的发送缓冲区状态变化时触发写事件，即满的缓冲区刚空出空间时触发读事件<br> 备注：仅在状态变化时触发事件</li>
</ol>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/20180531185610344" alt="img"></p>
<p>总结一下：</p>
<ol>
<li><p>对于监听的 sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，可以用 while 来循环 accept()。</p>
</li>
<li><p>对于读写的 connfd，水平触发模式下，阻塞和非阻塞效果都一样，因为在阻塞模式下，如果数据读取不完全则返回继续触发，反之读取完则返回继续等待。全建议设置非阻塞。</p>
</li>
<li><p>对于读写的 connfd，边缘触发模式下，必须使用非阻塞 IO，并要求一次性地完整读写全部数据。</p>
</li>
</ol>
<p><a href="https://blog.csdn.net/zxm342698145/article/details/80524331/">https://blog.csdn.net/zxm342698145/article/details/80524331/</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1736793">https://cloud.tencent.com/developer/article/1736793</a></p>
<p><a href="https://blog.csdn.net/dongfuye/article/details/50880251">https://blog.csdn.net/dongfuye/article/details/50880251</a></p>
<p><a href="https://www.zhihu.com/question/20502870">https://www.zhihu.com/question/20502870</a></p>
<p><a href="https://blog.lucode.net/linux/epoll-tutorial.html">https://blog.lucode.net/linux/epoll-tutorial.html</a></p>
<p><a href="https://plantegg.github.io/2019/12/09/epoll%E7%9A%84LT%E5%92%8CET/">https://plantegg.github.io/2019/12/09/epoll%E7%9A%84LT%E5%92%8CET/</a></p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>rpc、socket、tcp/udp整理梳理</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/tcp%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p><strong>RPC</strong>:远程过程调用（分布式、微服务间的方法调用）</p>
<p><strong>HTTP</strong>:无状态，每次请求都要发送一个request，服务器响应之后就断掉（http header中的keep-alive指的是tcp）</p>
<p><strong>TCP</strong>:面向连接，三次握手保证通信可靠</p>
<p><strong>UDP</strong>:非面向连接，不可靠，速度快（可以手动对数据收发进行验证，IM系统多采用，QQ）</p>
<p><strong>Socket</strong>:TCP协议的接口实现，面向传输层进行网络编程, socket并不是一种协议，是在程序员层面上对TCP&#x2F;IP协议的封装和应用。其实是一个调用接口，方便程序员使用TCP&#x2F;IP协议栈而已。程序员通过socket来使用tcp&#x2F;ip协议。但是socket并不是一定要使用tcp&#x2F;ip协议，Socket编程接口在设计的时候，就希望也能适应其他的网络协议。</p>
<p><strong>RPC(Remote Procedure Call)是远程过程调用</strong>，比如说现在有两台服务器A, B，一个在A服务器上的应用想要调用B服务器上的应用提供的某个，由于不在两个方法不在一个内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。常存在于分布式系统中。</p>
<p>RPC跟HTTP不是对立面，RPC中可以使用HTTP作为通讯协议。<strong>RPC是一种设计、实现框架</strong>，通讯协议只是其中一部分。</p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>网络基础</title>
    <url>/2022/02/17/%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ul>
<li><p>time_wait 是主动发起关闭连接的一方所处的状态，如果这一方有大量的time_wait,可能是短链接，也可能就是流量大了【攻击】；</p>
<ul>
<li>表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭 </li>
<li>net.ipv4.tcp_tw_reuse &#x3D; 1 </li>
<li>#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭 </li>
<li>net.ipv4.tcp_tw_recycle &#x3D; 1 </li>
<li>表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间 </li>
<li>net.ipv4.tcp_fin_timeout&#x3D;30</li>
</ul>
</li>
<li><p>close_wait:一般是漏写close函数</p>
<span id="more"></span>
</li>
<li><p>tcp</p>
<ul>
<li>为了解决这个问题，TCP引入了窗口，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。ack包中的win是告诉对端，我方的接受窗口是多大，接受能力。</li>
<li>发送端不能疯狂地向接收端发送数据，因为接收端接收不过来的话，接收方只能把处理不过来的数据存在缓存区里。如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源啦。TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的据量，这就是流量控制。TCP通过滑动窗口来控制流量。</li>
</ul>
</li>
<li><h5 id="流量控制（copy）"><a href="#流量控制（copy）" class="headerlink" title="流量控制（copy）"></a>流量控制（copy）</h5><ul>
<li>TCP通过滑动窗口来控制流量，我们看下流量控制的<strong>简要流程</strong>吧：</li>
<li>首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。</li>
<li><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/640" alt="图片">TCP的流量控制</li>
<li>假如当前发送方给接收方发送了200个字节，那么，发送方的<code>SND.NXT</code>会右移200个字节，也就是说当前的可用窗口减少了200 个字节。</li>
<li>接受方收到后，放到缓冲队列里面，REV.WND &#x3D;400-200&#x3D;200字节，所以win&#x3D;200字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口200字节</li>
<li>发送方又发送200字节过来，200字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理100字节，剩余的100字节继续放到缓冲队列。这时候，REV.WND &#x3D; 400-200-100&#x3D;100字节，即win&#x3D;100返回发送方。</li>
<li>发送方继续干活，发送100字节过来，这时候，接受窗口win变为0。</li>
<li>发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到win大于0，才继续开始发送。</li>
</ul>
</li>
<li><h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><ul>
<li>定义：拥塞控制是<strong>作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况</strong>。它的目标主要是最大化利用网络上瓶颈链路的带宽。它跟<strong>流量控制</strong>又有什么区别呢？流量控制是作用于接收者的，根据<strong>接收端的实际接收能力控制发送速度</strong>，防止分组丢失的。我们可以把网络链路比喻成一根水管，如果我们想最大化利用网络来传输数据，那就是尽快让水管达到最佳充满状态。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net2.jpg" alt="net2"></p>
<p>发送方维护一个<strong>拥塞窗口cwnd（congestion window）</strong> 的变量，用来估算在一段时间内这条链路（水管）可以承载和运输的数据（水）的数量。它大小代表着网络的拥塞程度，并且是动态变化的，但是为了达到最大的传输效率，我们该如何知道这条水管的运送效率是多少呢？</p>
<p>一个比较简单的方法就是不断增加传输的水量，直到水管快要爆裂为止（对应到网络上就是发生丢包），用 TCP 的描述就是：</p>
<blockquote>
<p>★</p>
<p>只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。</p>
</blockquote>
<p>实际上，拥塞控制主要有这几种常用算法：<strong>慢启动、拥塞避免、拥塞发生、快速恢复</strong></p>
<h6 id="慢启动算法"><a href="#慢启动算法" class="headerlink" title="慢启动算法"></a>慢启动算法</h6><p>慢启动算法，表面意思就是，别急慢慢来。它表示TCP建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，<strong>每收到一个ACK，就将拥塞窗口cwnd大小就加1（单位是MSS）</strong>。<strong>每轮次</strong>发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。</p>
<p>TCP连接完成，初始化cwnd &#x3D; 1，表明可以传一个MSS单位大小的数据。</p>
<p>每当收到一个ACK，cwnd就加一;</p>
<p>每当过了一个RTT，cwnd就增加一倍; 呈指数让升</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net3.jpg" alt="net3"></p>
<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个<strong>慢启动阀值ssthresh</strong>（slow start threshold）状态变量。当<code>cwnd</code>到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当<strong>cwnd &gt;ssthresh</strong>时，进入了<strong>拥塞避免</strong>算法。</p>
<h6 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h6><p>一般来说，慢启动阀值ssthresh是65535字节，<code>cwnd</code>到达<strong>慢启动阀值</strong>后</p>
<p>每收到一个ACK时，cwnd &#x3D; cwnd + 1&#x2F;cwnd</p>
<p>当每过一个RTT时，cwnd &#x3D; cwnd + 1</p>
<p>显然这是一个线性上升的算法，避免过快导致网络拥塞问题。</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net4.jpg" alt="net4"></p>
<h4 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h4><p>当网络拥塞发生<strong>丢包</strong>时，会有两种情况：RTO超时重传和快速重传；如果是发生了<strong>RTO超时重传</strong>，就会使用拥塞发生算法；慢启动阀值sshthresh &#x3D;  cwnd &#x2F;2，cwnd 重置为 1，进入新的慢启动过程</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net5.jpg" alt="net5"></p>
<p>这真的是<strong>辛辛苦苦几十年，一朝回到解放前</strong>。其实还有更好的处理方式，就是<strong>快速重传</strong>。发送方收到3个连续重复的ACK时，就会快速地重传，不必等待<strong>RTO超时</strong>再重传。</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net6.jpg" alt="net6"></p>
<p>慢启动阀值ssthresh 和 cwnd 变化如下：拥塞窗口大小 cwnd &#x3D; cwnd&#x2F;2，慢启动阀值 ssthresh &#x3D; cwnd，进入快速恢复算法</p>
<h6 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h6><p>快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有3个重复ACK收到，说明网络也没那么糟糕，所以没有必要像RTO超时那么强烈。正如前面所说，进入快速恢复之前，cwnd 和 sshthresh已被更新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- cwnd = cwnd /2</span><br><span class="line">- sshthresh = cwnd</span><br></pre></td></tr></table></figure>

<p>然后，真正的快速算法如下：cwnd &#x3D; sshthresh  + 3，重传重复的那几个ACK（即丢失的那几个数据包）如果再收到重复的 ACK，那么 cwnd &#x3D; cwnd +1；如果收到新数据的 ACK 后, cwnd &#x3D; sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</p>
<p><img src="https://raw.githubusercontent.com/yefengdanqing/picture_bed/master/img/net7.jpg" alt="net7"></p>
</li>
<li><p>半连接队列和全连接队列</p>
</li>
<li><ol>
<li>半连接队列（SYN队列）：发送了开始建立连接的</li>
<li>全连接队列（ACCEPT队列）: 客户端也发送了ack之后就放入全连接队列</li>
</ol>
</li>
<li><p>socket阻塞是相对于发生在io读写的时候，一般读io是非阻塞的，而写io都是阻塞的；我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>样例模板</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/k8s/k8s/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>kubectl get pod <pod-name> -o yaml 查看 Pod 的配置是否正确<br>kubectl describe pod <pod-name> 查看 Pod 的事件<br>kubectl logs <pod-name> [-c <container-name>] 查看容器日志</p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>样例模板</title>
    <url>/2022/03/04/%E5%9F%BA%E7%A1%80/python/python/</url>
    <content><![CDATA[<h3 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h3><p>Mac: brew install python,然后通过python -v 来查看是2还是3</p>
<h3 id="安装-Pipenv"><a href="#安装-Pipenv" class="headerlink" title="安装 Pipenv"></a>安装 Pipenv</h3><p>虚拟环境解决了包依赖不同版本的问题</p>
<p>pip install pipenv</p>
<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>网络相关</title>
    <url>/2022/08/18/%E9%AB%98%E5%B9%B6%E5%8F%91/seastar/%E6%A0%B7%E4%BE%8B%E6%A8%A1%E6%9D%BF%20(copy)/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
  </entry>
  <entry>
    <title>test111</title>
    <url>/2023/05/16/test111/</url>
    <content><![CDATA[<p>hexo new post “test111”</p>
<p>hexo new draft “test111”</p>
]]></content>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2023/04/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h5><span id="more"></span>

<p>* </p>
<h5 id="实际场景"><a href="#实际场景" class="headerlink" title="实际场景"></a>实际场景</h5><p>假如王二狗和牛翠花约好在天安门约会，两人从起点到目的地可以借助的通行方式比较多，至于选那种方式完全因人而异。</p>
<h5 id="使用方法（核心代码）"><a href="#使用方法（核心代码）" class="headerlink" title="使用方法（核心代码）"></a>使用方法（核心代码）</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span>；</span><br></pre></td></tr></table></figure>



<h4 id="模板方法模式适合应用场景"><a href="#模板方法模式适合应用场景" class="headerlink" title="模板方法模式适合应用场景"></a>模板方法模式适合应用场景</h4><h4 id="实现方式（类图）"><a href="#实现方式（类图）" class="headerlink" title="实现方式（类图）"></a>实现方式（类图）</h4><h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><p>优点：</p>
<p>缺点：</p>
<h4 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
